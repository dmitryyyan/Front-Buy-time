{"ast":null,"code":"/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      explanation,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n    super(explanation ?? msg);\n    if (explanation != null) this.cause = msg;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n    this.failures = () => {\n      return cached ?? (cached = [failure, ...failures()]);\n    };\n  }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n  return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n  if (typeof value === 'symbol') {\n    return value.toString();\n  }\n  return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch,\n    mask\n  };\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n  }\n  let status = 'valid';\n  for (const failure of struct.validator(value, ctx)) {\n    failure.explanation = options.message;\n    status = 'not_valid';\n    yield [failure, undefined];\n  }\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask,\n      message: options.message\n    });\n    for (const t of ts) {\n      if (t[0]) {\n        status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          if (v !== undefined || k in value) value[k] = v;\n        }\n      }\n    }\n  }\n  if (status !== 'not_valid') {\n    for (const failure of struct.refiner(value, ctx)) {\n      failure.explanation = options.message;\n      status = 'not_refined';\n      yield [failure, undefined];\n    }\n  }\n  if (status === 'valid') {\n    yield [undefined, value];\n  }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n  assert(value, message) {\n    return assert(value, this, message);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n  create(value, message) {\n    return create(value, this, message);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema. Masking applies recursively to\n   * props of `object` structs only.\n   */\n  mask(value, message) {\n    return mask(value, this, message);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `coerce` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful. Also, `mask` will turn on\n   * masking of the unknown `object` props recursively if passed.\n   */\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n  const result = validate(value, struct, {\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true,\n    message\n  });\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\nfunction assign(...Structs) {\n  const isType = Structs[0].type === 'type';\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n  return new Struct({\n    ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n    *entries(value, ctx) {\n      struct ?? (struct = fn());\n      yield* struct.entries(value, ctx);\n    },\n    validator(value, ctx) {\n      struct ?? (struct = fn());\n      return struct.validator(value, ctx);\n    },\n    coercer(value, ctx) {\n      struct ?? (struct = fn());\n      return struct.coercer(value, ctx);\n    },\n    refiner(value, ctx) {\n      struct ?? (struct = fn());\n      return struct.refiner(value, ctx);\n    }\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {\n    ...schema\n  };\n  for (const key of keys) {\n    delete subschema[key];\n  }\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n  const isStruct = struct instanceof Struct;\n  const schema = isStruct ? {\n    ...struct.schema\n  } : {\n    ...struct\n  };\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n  if (isStruct && struct.type === 'type') {\n    return type(schema);\n  }\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n  switch (struct.type) {\n    case 'type':\n      return type(subschema);\n    default:\n      return object(subschema);\n  }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n    validator(value) {\n      return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n    }\n  });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n  return define('bigint', value => {\n    return typeof value === 'bigint';\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || `Expected a valid \\`Date\\` object, but received: ${print(value)}`;\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n  for (const key of values) {\n    schema[key] = key;\n  }\n  return new Struct({\n    type: 'enums',\n    schema,\n    validator(value) {\n      return values.includes(value) || `Expected one of \\`${description}\\`, but received: ${print(value)}`;\n    }\n  });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || `Expected a function, but received: ${print(value)}`;\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || `Expected an integer, but received: ${print(value)}`;\n  });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n    validator(value) {\n      return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n    }\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n    validator(value) {\n      return value instanceof Map || `Expected a \\`Map\\` object, but received: ${print(value)}`;\n    }\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n    validator(value) {\n      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n    },\n    coercer(value, ctx) {\n      if (!isNonArrayObject(value)) {\n        return value;\n      }\n      const coerced = {\n        ...value\n      };\n      // The `object` struct has special behaviour enabled by the mask flag.\n      // When masking, properties that are not in the schema are deleted from\n      // the coerced object instead of eventually failing validaiton.\n      if (ctx.mask && schema) {\n        for (const key in coerced) {\n          if (schema[key] === undefined) {\n            delete coerced[key];\n          }\n        }\n      }\n      return coerced;\n    }\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n  return new Struct({\n    ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n    validator(value) {\n      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n    },\n    coercer(value) {\n      return isNonArrayObject(value) ? {\n        ...value\n      } : value;\n    }\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n    validator(value) {\n      return value instanceof Set || `Expected a \\`Set\\` object, but received: ${print(value)}`;\n    }\n  });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || `Expected a string, but received: ${print(value)}`;\n  });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Structs.length, value.length);\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Structs[i] || Never];\n        }\n      }\n    },\n    validator(value) {\n      return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n    },\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    }\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n    validator(value) {\n      return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n    },\n    coercer(value) {\n      return isNonArrayObject(value) ? {\n        ...value\n      } : value;\n    }\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n    coercer(value, ctx) {\n      for (const S of Structs) {\n        const [error, coerced] = S.validate(value, {\n          coerce: true,\n          mask: ctx.mask\n        });\n        if (!error) {\n          return coerced;\n        }\n      }\n      return value;\n    },\n    validator(value, ctx) {\n      const failures = [];\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n      return [`Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`, ...failures];\n    }\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n  return new Struct({\n    ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n    if (x === undefined) {\n      return f;\n    }\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = {\n        ...x\n      };\n      let changed = false;\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n      if (changed) {\n        return ret;\n      }\n    }\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n  return refine(struct, 'empty', value => {\n    const size = getSize(value);\n    return size === 0 || `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``;\n  });\n}\nfunction getSize(value) {\n  if (value instanceof Map || value instanceof Set) {\n    return value.size;\n  } else {\n    return value.length;\n  }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n  });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n  return refine(struct, 'nonempty', value => {\n    const size = getSize(value);\n    return size > 0 || `Expected a nonempty ${struct.type} but received an empty one`;\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`;\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n  const expected = `Expected a ${struct.type}`;\n  const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || `${expected} ${of} but received \\`${value}\\``;\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || `${expected} with a size ${of} but received one with a size of \\`${size}\\``;\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || `${expected} with a length ${of} but received one with a length of \\`${length}\\``;\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n  return new Struct({\n    ...struct,\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n      for (const failure of failures) {\n        yield {\n          ...failure,\n          refinement: name\n        };\n      }\n    }\n  });\n}\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };","map":{"version":3,"names":["StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","msg","length","join","cause","Object","assign","name","isIterable","x","isObject","Symbol","iterator","isNonArrayObject","Array","isArray","isPlainObject","prototype","toString","call","getPrototypeOf","print","value","JSON","stringify","shiftIterator","input","done","next","undefined","toFailure","result","context","struct","branch","type","refinement","key","toFailures","r","run","options","coerce","mask","ctx","coercer","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","schema","assert","create","is","validate","tuples","tuple","error","Structs","isType","schemas","map","object","define","deprecated","log","dynamic","fn","lazy","omit","keys","subschema","partial","isStruct","optional","pick","console","warn","any","array","Element","i","slice","bigint","boolean","date","Date","isNaN","getTime","enums","values","description","includes","func","instance","Class","integer","Number","isInteger","intersection","S","literal","constant","Key","Value","never","nullable","number","knowns","Never","unknowns","delete","coerced","record","regexp","RegExp","string","Math","max","union","first","push","unknown","condition","defaulted","fallback","f","strict","ret","changed","trimmed","trim","empty","refine","size","getSize","threshold","exclusive","min","nonempty","pattern","test","source","expected","of"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/superstruct/dist/index.mjs"],"sourcesContent":["/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMA,WAAW,SAASC,SAAS,CAAC;EAChCC,WAAWA,CAACC,OAAO,EAAEC,QAAQ,EAAE;IAC3B,IAAIC,MAAM;IACV,MAAM;MAAEC,OAAO;MAAEC,WAAW;MAAE,GAAGC;IAAK,CAAC,GAAGL,OAAO;IACjD,MAAM;MAAEM;IAAK,CAAC,GAAGN,OAAO;IACxB,MAAMO,GAAG,GAAGD,IAAI,CAACE,MAAM,KAAK,CAAC,GAAGL,OAAO,GAAG,YAAYG,IAAI,CAACG,IAAI,CAAC,GAAG,CAAC,OAAON,OAAO,EAAE;IACpF,KAAK,CAACC,WAAW,IAAIG,GAAG,CAAC;IACzB,IAAIH,WAAW,IAAI,IAAI,EACnB,IAAI,CAACM,KAAK,GAAGH,GAAG;IACpBI,MAAM,CAACC,MAAM,CAAC,IAAI,EAAEP,IAAI,CAAC;IACzB,IAAI,CAACQ,IAAI,GAAG,IAAI,CAACd,WAAW,CAACc,IAAI;IACjC,IAAI,CAACZ,QAAQ,GAAG,MAAM;MAClB,OAAQC,MAAM,KAAKA,MAAM,GAAG,CAACF,OAAO,EAAE,GAAGC,QAAQ,CAAC,CAAC,CAAC,CAAC;IACzD,CAAC;EACL;AACJ;;AAEA;AACA;AACA;AACA,SAASa,UAAUA,CAACC,CAAC,EAAE;EACnB,OAAOC,QAAQ,CAACD,CAAC,CAAC,IAAI,OAAOA,CAAC,CAACE,MAAM,CAACC,QAAQ,CAAC,KAAK,UAAU;AAClE;AACA;AACA;AACA;AACA,SAASF,QAAQA,CAACD,CAAC,EAAE;EACjB,OAAO,OAAOA,CAAC,KAAK,QAAQ,IAAIA,CAAC,IAAI,IAAI;AAC7C;AACA;AACA;AACA;AACA,SAASI,gBAAgBA,CAACJ,CAAC,EAAE;EACzB,OAAOC,QAAQ,CAACD,CAAC,CAAC,IAAI,CAACK,KAAK,CAACC,OAAO,CAACN,CAAC,CAAC;AAC3C;AACA;AACA;AACA;AACA,SAASO,aAAaA,CAACP,CAAC,EAAE;EACtB,IAAIJ,MAAM,CAACY,SAAS,CAACC,QAAQ,CAACC,IAAI,CAACV,CAAC,CAAC,KAAK,iBAAiB,EAAE;IACzD,OAAO,KAAK;EAChB;EACA,MAAMQ,SAAS,GAAGZ,MAAM,CAACe,cAAc,CAACX,CAAC,CAAC;EAC1C,OAAOQ,SAAS,KAAK,IAAI,IAAIA,SAAS,KAAKZ,MAAM,CAACY,SAAS;AAC/D;AACA;AACA;AACA;AACA,SAASI,KAAKA,CAACC,KAAK,EAAE;EAClB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAOA,KAAK,CAACJ,QAAQ,CAAC,CAAC;EAC3B;EACA,OAAO,OAAOI,KAAK,KAAK,QAAQ,GAAGC,IAAI,CAACC,SAAS,CAACF,KAAK,CAAC,GAAG,GAAGA,KAAK,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA,SAASG,aAAaA,CAACC,KAAK,EAAE;EAC1B,MAAM;IAAEC,IAAI;IAAEL;EAAM,CAAC,GAAGI,KAAK,CAACE,IAAI,CAAC,CAAC;EACpC,OAAOD,IAAI,GAAGE,SAAS,GAAGP,KAAK;AACnC;AACA;AACA;AACA;AACA,SAASQ,SAASA,CAACC,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEX,KAAK,EAAE;EAC/C,IAAIS,MAAM,KAAK,IAAI,EAAE;IACjB;EACJ,CAAC,MACI,IAAIA,MAAM,KAAK,KAAK,EAAE;IACvBA,MAAM,GAAG,CAAC,CAAC;EACf,CAAC,MACI,IAAI,OAAOA,MAAM,KAAK,QAAQ,EAAE;IACjCA,MAAM,GAAG;MAAElC,OAAO,EAAEkC;IAAO,CAAC;EAChC;EACA,MAAM;IAAE/B,IAAI;IAAEkC;EAAO,CAAC,GAAGF,OAAO;EAChC,MAAM;IAAEG;EAAK,CAAC,GAAGF,MAAM;EACvB,MAAM;IAAEG,UAAU;IAAEvC,OAAO,GAAG,8BAA8BsC,IAAI,KAAKC,UAAU,GAAG,sBAAsBA,UAAU,IAAI,GAAG,EAAE,qBAAqBf,KAAK,CAACC,KAAK,CAAC;EAAM,CAAC,GAAGS,MAAM;EAC5K,OAAO;IACHT,KAAK;IACLa,IAAI;IACJC,UAAU;IACVC,GAAG,EAAErC,IAAI,CAACA,IAAI,CAACE,MAAM,GAAG,CAAC,CAAC;IAC1BF,IAAI;IACJkC,MAAM;IACN,GAAGH,MAAM;IACTlC;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA,UAAUyC,UAAUA,CAACP,MAAM,EAAEC,OAAO,EAAEC,MAAM,EAAEX,KAAK,EAAE;EACjD,IAAI,CAACd,UAAU,CAACuB,MAAM,CAAC,EAAE;IACrBA,MAAM,GAAG,CAACA,MAAM,CAAC;EACrB;EACA,KAAK,MAAMQ,CAAC,IAAIR,MAAM,EAAE;IACpB,MAAMrC,OAAO,GAAGoC,SAAS,CAACS,CAAC,EAAEP,OAAO,EAAEC,MAAM,EAAEX,KAAK,CAAC;IACpD,IAAI5B,OAAO,EAAE;MACT,MAAMA,OAAO;IACjB;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA,UAAU8C,GAAGA,CAAClB,KAAK,EAAEW,MAAM,EAAEQ,OAAO,GAAG,CAAC,CAAC,EAAE;EACvC,MAAM;IAAEzC,IAAI,GAAG,EAAE;IAAEkC,MAAM,GAAG,CAACZ,KAAK,CAAC;IAAEoB,MAAM,GAAG,KAAK;IAAEC,IAAI,GAAG;EAAM,CAAC,GAAGF,OAAO;EAC7E,MAAMG,GAAG,GAAG;IAAE5C,IAAI;IAAEkC,MAAM;IAAES;EAAK,CAAC;EAClC,IAAID,MAAM,EAAE;IACRpB,KAAK,GAAGW,MAAM,CAACY,OAAO,CAACvB,KAAK,EAAEsB,GAAG,CAAC;EACtC;EACA,IAAIE,MAAM,GAAG,OAAO;EACpB,KAAK,MAAMpD,OAAO,IAAIuC,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC,EAAE;IAChDlD,OAAO,CAACI,WAAW,GAAG2C,OAAO,CAAC5C,OAAO;IACrCiD,MAAM,GAAG,WAAW;IACpB,MAAM,CAACpD,OAAO,EAAEmC,SAAS,CAAC;EAC9B;EACA,KAAK,IAAI,CAACmB,CAAC,EAAEC,CAAC,EAAEC,CAAC,CAAC,IAAIjB,MAAM,CAACkB,OAAO,CAAC7B,KAAK,EAAEsB,GAAG,CAAC,EAAE;IAC9C,MAAMQ,EAAE,GAAGZ,GAAG,CAACS,CAAC,EAAEC,CAAC,EAAE;MACjBlD,IAAI,EAAEgD,CAAC,KAAKnB,SAAS,GAAG7B,IAAI,GAAG,CAAC,GAAGA,IAAI,EAAEgD,CAAC,CAAC;MAC3Cd,MAAM,EAAEc,CAAC,KAAKnB,SAAS,GAAGK,MAAM,GAAG,CAAC,GAAGA,MAAM,EAAEe,CAAC,CAAC;MACjDP,MAAM;MACNC,IAAI;MACJ9C,OAAO,EAAE4C,OAAO,CAAC5C;IACrB,CAAC,CAAC;IACF,KAAK,MAAMwD,CAAC,IAAID,EAAE,EAAE;MAChB,IAAIC,CAAC,CAAC,CAAC,CAAC,EAAE;QACNP,MAAM,GAAGO,CAAC,CAAC,CAAC,CAAC,CAACjB,UAAU,IAAI,IAAI,GAAG,aAAa,GAAG,WAAW;QAC9D,MAAM,CAACiB,CAAC,CAAC,CAAC,CAAC,EAAExB,SAAS,CAAC;MAC3B,CAAC,MACI,IAAIa,MAAM,EAAE;QACbO,CAAC,GAAGI,CAAC,CAAC,CAAC,CAAC;QACR,IAAIL,CAAC,KAAKnB,SAAS,EAAE;UACjBP,KAAK,GAAG2B,CAAC;QACb,CAAC,MACI,IAAI3B,KAAK,YAAYgC,GAAG,EAAE;UAC3BhC,KAAK,CAACiC,GAAG,CAACP,CAAC,EAAEC,CAAC,CAAC;QACnB,CAAC,MACI,IAAI3B,KAAK,YAAYkC,GAAG,EAAE;UAC3BlC,KAAK,CAACmC,GAAG,CAACR,CAAC,CAAC;QAChB,CAAC,MACI,IAAIvC,QAAQ,CAACY,KAAK,CAAC,EAAE;UACtB,IAAI2B,CAAC,KAAKpB,SAAS,IAAImB,CAAC,IAAI1B,KAAK,EAC7BA,KAAK,CAAC0B,CAAC,CAAC,GAAGC,CAAC;QACpB;MACJ;IACJ;EACJ;EACA,IAAIH,MAAM,KAAK,WAAW,EAAE;IACxB,KAAK,MAAMpD,OAAO,IAAIuC,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC,EAAE;MAC9ClD,OAAO,CAACI,WAAW,GAAG2C,OAAO,CAAC5C,OAAO;MACrCiD,MAAM,GAAG,aAAa;MACtB,MAAM,CAACpD,OAAO,EAAEmC,SAAS,CAAC;IAC9B;EACJ;EACA,IAAIiB,MAAM,KAAK,OAAO,EAAE;IACpB,MAAM,CAACjB,SAAS,EAAEP,KAAK,CAAC;EAC5B;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMqC,MAAM,CAAC;EACTlE,WAAWA,CAACmE,KAAK,EAAE;IACf,MAAM;MAAEzB,IAAI;MAAE0B,MAAM;MAAEd,SAAS;MAAEW,OAAO;MAAEb,OAAO,GAAIvB,KAAK,IAAKA,KAAK;MAAE6B,OAAO,GAAG,UAAAA,CAAA,EAAa,CAAE;IAAG,CAAC,GAAGS,KAAK;IAC3G,IAAI,CAACzB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC0B,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACV,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACN,OAAO,GAAGA,OAAO;IACtB,IAAIE,SAAS,EAAE;MACX,IAAI,CAACA,SAAS,GAAG,CAACzB,KAAK,EAAEU,OAAO,KAAK;QACjC,MAAMD,MAAM,GAAGgB,SAAS,CAACzB,KAAK,EAAEU,OAAO,CAAC;QACxC,OAAOM,UAAU,CAACP,MAAM,EAAEC,OAAO,EAAE,IAAI,EAAEV,KAAK,CAAC;MACnD,CAAC;IACL,CAAC,MACI;MACD,IAAI,CAACyB,SAAS,GAAG,MAAM,EAAE;IAC7B;IACA,IAAIW,OAAO,EAAE;MACT,IAAI,CAACA,OAAO,GAAG,CAACpC,KAAK,EAAEU,OAAO,KAAK;QAC/B,MAAMD,MAAM,GAAG2B,OAAO,CAACpC,KAAK,EAAEU,OAAO,CAAC;QACtC,OAAOM,UAAU,CAACP,MAAM,EAAEC,OAAO,EAAE,IAAI,EAAEV,KAAK,CAAC;MACnD,CAAC;IACL,CAAC,MACI;MACD,IAAI,CAACoC,OAAO,GAAG,MAAM,EAAE;IAC3B;EACJ;EACA;AACJ;AACA;EACII,MAAMA,CAACxC,KAAK,EAAEzB,OAAO,EAAE;IACnB,OAAOiE,MAAM,CAACxC,KAAK,EAAE,IAAI,EAAEzB,OAAO,CAAC;EACvC;EACA;AACJ;AACA;EACIkE,MAAMA,CAACzC,KAAK,EAAEzB,OAAO,EAAE;IACnB,OAAOkE,MAAM,CAACzC,KAAK,EAAE,IAAI,EAAEzB,OAAO,CAAC;EACvC;EACA;AACJ;AACA;EACImE,EAAEA,CAAC1C,KAAK,EAAE;IACN,OAAO0C,EAAE,CAAC1C,KAAK,EAAE,IAAI,CAAC;EAC1B;EACA;AACJ;AACA;AACA;AACA;EACIqB,IAAIA,CAACrB,KAAK,EAAEzB,OAAO,EAAE;IACjB,OAAO8C,IAAI,CAACrB,KAAK,EAAE,IAAI,EAAEzB,OAAO,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIoE,QAAQA,CAAC3C,KAAK,EAAEmB,OAAO,GAAG,CAAC,CAAC,EAAE;IAC1B,OAAOwB,QAAQ,CAAC3C,KAAK,EAAE,IAAI,EAAEmB,OAAO,CAAC;EACzC;AACJ;AACA;AACA;AACA;AACA,SAASqB,MAAMA,CAACxC,KAAK,EAAEW,MAAM,EAAEpC,OAAO,EAAE;EACpC,MAAMkC,MAAM,GAAGkC,QAAQ,CAAC3C,KAAK,EAAEW,MAAM,EAAE;IAAEpC;EAAQ,CAAC,CAAC;EACnD,IAAIkC,MAAM,CAAC,CAAC,CAAC,EAAE;IACX,MAAMA,MAAM,CAAC,CAAC,CAAC;EACnB;AACJ;AACA;AACA;AACA;AACA,SAASgC,MAAMA,CAACzC,KAAK,EAAEW,MAAM,EAAEpC,OAAO,EAAE;EACpC,MAAMkC,MAAM,GAAGkC,QAAQ,CAAC3C,KAAK,EAAEW,MAAM,EAAE;IAAES,MAAM,EAAE,IAAI;IAAE7C;EAAQ,CAAC,CAAC;EACjE,IAAIkC,MAAM,CAAC,CAAC,CAAC,EAAE;IACX,MAAMA,MAAM,CAAC,CAAC,CAAC;EACnB,CAAC,MACI;IACD,OAAOA,MAAM,CAAC,CAAC,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA,SAASY,IAAIA,CAACrB,KAAK,EAAEW,MAAM,EAAEpC,OAAO,EAAE;EAClC,MAAMkC,MAAM,GAAGkC,QAAQ,CAAC3C,KAAK,EAAEW,MAAM,EAAE;IAAES,MAAM,EAAE,IAAI;IAAEC,IAAI,EAAE,IAAI;IAAE9C;EAAQ,CAAC,CAAC;EAC7E,IAAIkC,MAAM,CAAC,CAAC,CAAC,EAAE;IACX,MAAMA,MAAM,CAAC,CAAC,CAAC;EACnB,CAAC,MACI;IACD,OAAOA,MAAM,CAAC,CAAC,CAAC;EACpB;AACJ;AACA;AACA;AACA;AACA,SAASiC,EAAEA,CAAC1C,KAAK,EAAEW,MAAM,EAAE;EACvB,MAAMF,MAAM,GAAGkC,QAAQ,CAAC3C,KAAK,EAAEW,MAAM,CAAC;EACtC,OAAO,CAACF,MAAM,CAAC,CAAC,CAAC;AACrB;AACA;AACA;AACA;AACA;AACA,SAASkC,QAAQA,CAAC3C,KAAK,EAAEW,MAAM,EAAEQ,OAAO,GAAG,CAAC,CAAC,EAAE;EAC3C,MAAMyB,MAAM,GAAG1B,GAAG,CAAClB,KAAK,EAAEW,MAAM,EAAEQ,OAAO,CAAC;EAC1C,MAAM0B,KAAK,GAAG1C,aAAa,CAACyC,MAAM,CAAC;EACnC,IAAIC,KAAK,CAAC,CAAC,CAAC,EAAE;IACV,MAAMC,KAAK,GAAG,IAAI7E,WAAW,CAAC4E,KAAK,CAAC,CAAC,CAAC,EAAE,aAAa;MACjD,KAAK,MAAMd,CAAC,IAAIa,MAAM,EAAE;QACpB,IAAIb,CAAC,CAAC,CAAC,CAAC,EAAE;UACN,MAAMA,CAAC,CAAC,CAAC,CAAC;QACd;MACJ;IACJ,CAAC,CAAC;IACF,OAAO,CAACe,KAAK,EAAEvC,SAAS,CAAC;EAC7B,CAAC,MACI;IACD,MAAMoB,CAAC,GAAGkB,KAAK,CAAC,CAAC,CAAC;IAClB,OAAO,CAACtC,SAAS,EAAEoB,CAAC,CAAC;EACzB;AACJ;AAEA,SAAS3C,MAAMA,CAAC,GAAG+D,OAAO,EAAE;EACxB,MAAMC,MAAM,GAAGD,OAAO,CAAC,CAAC,CAAC,CAAClC,IAAI,KAAK,MAAM;EACzC,MAAMoC,OAAO,GAAGF,OAAO,CAACG,GAAG,CAAEtB,CAAC,IAAKA,CAAC,CAACW,MAAM,CAAC;EAC5C,MAAMA,MAAM,GAAGxD,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE,GAAGiE,OAAO,CAAC;EAC5C,OAAOD,MAAM,GAAGnC,IAAI,CAAC0B,MAAM,CAAC,GAAGY,MAAM,CAACZ,MAAM,CAAC;AACjD;AACA;AACA;AACA;AACA,SAASa,MAAMA,CAACnE,IAAI,EAAEwC,SAAS,EAAE;EAC7B,OAAO,IAAIY,MAAM,CAAC;IAAExB,IAAI,EAAE5B,IAAI;IAAEsD,MAAM,EAAE,IAAI;IAAEd;EAAU,CAAC,CAAC;AAC9D;AACA;AACA;AACA;AACA;AACA,SAAS4B,UAAUA,CAAC1C,MAAM,EAAE2C,GAAG,EAAE;EAC7B,OAAO,IAAIjB,MAAM,CAAC;IACd,GAAG1B,MAAM;IACTyB,OAAO,EAAEA,CAACpC,KAAK,EAAEsB,GAAG,KAAKtB,KAAK,KAAKO,SAAS,IAAII,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;IAC1EG,SAASA,CAACzB,KAAK,EAAEsB,GAAG,EAAE;MAClB,IAAItB,KAAK,KAAKO,SAAS,EAAE;QACrB,OAAO,IAAI;MACf,CAAC,MACI;QACD+C,GAAG,CAACtD,KAAK,EAAEsB,GAAG,CAAC;QACf,OAAOX,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;MACvC;IACJ;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASiC,OAAOA,CAACC,EAAE,EAAE;EACjB,OAAO,IAAInB,MAAM,CAAC;IACdxB,IAAI,EAAE,SAAS;IACf0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAEsB,GAAG,EAAE;MACjB,MAAMX,MAAM,GAAG6C,EAAE,CAACxD,KAAK,EAAEsB,GAAG,CAAC;MAC7B,OAAOX,MAAM,CAACkB,OAAO,CAAC7B,KAAK,EAAEsB,GAAG,CAAC;IACrC,CAAC;IACDG,SAASA,CAACzB,KAAK,EAAEsB,GAAG,EAAE;MAClB,MAAMX,MAAM,GAAG6C,EAAE,CAACxD,KAAK,EAAEsB,GAAG,CAAC;MAC7B,OAAOX,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;IACvC,CAAC;IACDC,OAAOA,CAACvB,KAAK,EAAEsB,GAAG,EAAE;MAChB,MAAMX,MAAM,GAAG6C,EAAE,CAACxD,KAAK,EAAEsB,GAAG,CAAC;MAC7B,OAAOX,MAAM,CAACY,OAAO,CAACvB,KAAK,EAAEsB,GAAG,CAAC;IACrC,CAAC;IACDc,OAAOA,CAACpC,KAAK,EAAEsB,GAAG,EAAE;MAChB,MAAMX,MAAM,GAAG6C,EAAE,CAACxD,KAAK,EAAEsB,GAAG,CAAC;MAC7B,OAAOX,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;IACrC;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmC,IAAIA,CAACD,EAAE,EAAE;EACd,IAAI7C,MAAM;EACV,OAAO,IAAI0B,MAAM,CAAC;IACdxB,IAAI,EAAE,MAAM;IACZ0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAEsB,GAAG,EAAE;MACjBX,MAAM,KAAKA,MAAM,GAAG6C,EAAE,CAAC,CAAC,CAAC;MACzB,OAAO7C,MAAM,CAACkB,OAAO,CAAC7B,KAAK,EAAEsB,GAAG,CAAC;IACrC,CAAC;IACDG,SAASA,CAACzB,KAAK,EAAEsB,GAAG,EAAE;MAClBX,MAAM,KAAKA,MAAM,GAAG6C,EAAE,CAAC,CAAC,CAAC;MACzB,OAAO7C,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;IACvC,CAAC;IACDC,OAAOA,CAACvB,KAAK,EAAEsB,GAAG,EAAE;MAChBX,MAAM,KAAKA,MAAM,GAAG6C,EAAE,CAAC,CAAC,CAAC;MACzB,OAAO7C,MAAM,CAACY,OAAO,CAACvB,KAAK,EAAEsB,GAAG,CAAC;IACrC,CAAC;IACDc,OAAOA,CAACpC,KAAK,EAAEsB,GAAG,EAAE;MAChBX,MAAM,KAAKA,MAAM,GAAG6C,EAAE,CAAC,CAAC,CAAC;MACzB,OAAO7C,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;IACrC;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoC,IAAIA,CAAC/C,MAAM,EAAEgD,IAAI,EAAE;EACxB,MAAM;IAAEpB;EAAO,CAAC,GAAG5B,MAAM;EACzB,MAAMiD,SAAS,GAAG;IAAE,GAAGrB;EAAO,CAAC;EAC/B,KAAK,MAAMxB,GAAG,IAAI4C,IAAI,EAAE;IACpB,OAAOC,SAAS,CAAC7C,GAAG,CAAC;EACzB;EACA,QAAQJ,MAAM,CAACE,IAAI;IACf,KAAK,MAAM;MACP,OAAOA,IAAI,CAAC+C,SAAS,CAAC;IAC1B;MACI,OAAOT,MAAM,CAACS,SAAS,CAAC;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,OAAOA,CAAClD,MAAM,EAAE;EACrB,MAAMmD,QAAQ,GAAGnD,MAAM,YAAY0B,MAAM;EACzC,MAAME,MAAM,GAAGuB,QAAQ,GAAG;IAAE,GAAGnD,MAAM,CAAC4B;EAAO,CAAC,GAAG;IAAE,GAAG5B;EAAO,CAAC;EAC9D,KAAK,MAAMI,GAAG,IAAIwB,MAAM,EAAE;IACtBA,MAAM,CAACxB,GAAG,CAAC,GAAGgD,QAAQ,CAACxB,MAAM,CAACxB,GAAG,CAAC,CAAC;EACvC;EACA,IAAI+C,QAAQ,IAAInD,MAAM,CAACE,IAAI,KAAK,MAAM,EAAE;IACpC,OAAOA,IAAI,CAAC0B,MAAM,CAAC;EACvB;EACA,OAAOY,MAAM,CAACZ,MAAM,CAAC;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyB,IAAIA,CAACrD,MAAM,EAAEgD,IAAI,EAAE;EACxB,MAAM;IAAEpB;EAAO,CAAC,GAAG5B,MAAM;EACzB,MAAMiD,SAAS,GAAG,CAAC,CAAC;EACpB,KAAK,MAAM7C,GAAG,IAAI4C,IAAI,EAAE;IACpBC,SAAS,CAAC7C,GAAG,CAAC,GAAGwB,MAAM,CAACxB,GAAG,CAAC;EAChC;EACA,QAAQJ,MAAM,CAACE,IAAI;IACf,KAAK,MAAM;MACP,OAAOA,IAAI,CAAC+C,SAAS,CAAC;IAC1B;MACI,OAAOT,MAAM,CAACS,SAAS,CAAC;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,SAASjD,MAAMA,CAAC1B,IAAI,EAAEwC,SAAS,EAAE;EAC7BwC,OAAO,CAACC,IAAI,CAAC,sEAAsE,CAAC;EACpF,OAAOd,MAAM,CAACnE,IAAI,EAAEwC,SAAS,CAAC;AAClC;;AAEA;AACA;AACA;AACA,SAAS0C,GAAGA,CAAA,EAAG;EACX,OAAOf,MAAM,CAAC,KAAK,EAAE,MAAM,IAAI,CAAC;AACpC;AACA,SAASgB,KAAKA,CAACC,OAAO,EAAE;EACpB,OAAO,IAAIhC,MAAM,CAAC;IACdxB,IAAI,EAAE,OAAO;IACb0B,MAAM,EAAE8B,OAAO;IACf,CAACxC,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIqE,OAAO,IAAI7E,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,EAAE;QACjC,KAAK,MAAM,CAACsE,CAAC,EAAE3C,CAAC,CAAC,IAAI3B,KAAK,CAAC6B,OAAO,CAAC,CAAC,EAAE;UAClC,MAAM,CAACyC,CAAC,EAAE3C,CAAC,EAAE0C,OAAO,CAAC;QACzB;MACJ;IACJ,CAAC;IACD9C,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,GAAGA,KAAK,CAACuE,KAAK,CAAC,CAAC,GAAGvE,KAAK;IACvD,CAAC;IACDyB,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,IACxB,0CAA0CD,KAAK,CAACC,KAAK,CAAC,EAAE;IAChE;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASwE,MAAMA,CAAA,EAAG;EACd,OAAOpB,MAAM,CAAC,QAAQ,EAAGpD,KAAK,IAAK;IAC/B,OAAO,OAAOA,KAAK,KAAK,QAAQ;EACpC,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASyE,OAAOA,CAAA,EAAG;EACf,OAAOrB,MAAM,CAAC,SAAS,EAAGpD,KAAK,IAAK;IAChC,OAAO,OAAOA,KAAK,KAAK,SAAS;EACrC,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0E,IAAIA,CAAA,EAAG;EACZ,OAAOtB,MAAM,CAAC,MAAM,EAAGpD,KAAK,IAAK;IAC7B,OAASA,KAAK,YAAY2E,IAAI,IAAI,CAACC,KAAK,CAAC5E,KAAK,CAAC6E,OAAO,CAAC,CAAC,CAAC,IACrD,mDAAmD9E,KAAK,CAACC,KAAK,CAAC,EAAE;EACzE,CAAC,CAAC;AACN;AACA,SAAS8E,KAAKA,CAACC,MAAM,EAAE;EACnB,MAAMxC,MAAM,GAAG,CAAC,CAAC;EACjB,MAAMyC,WAAW,GAAGD,MAAM,CAAC7B,GAAG,CAAEvB,CAAC,IAAK5B,KAAK,CAAC4B,CAAC,CAAC,CAAC,CAAC9C,IAAI,CAAC,CAAC;EACtD,KAAK,MAAMkC,GAAG,IAAIgE,MAAM,EAAE;IACtBxC,MAAM,CAACxB,GAAG,CAAC,GAAGA,GAAG;EACrB;EACA,OAAO,IAAIsB,MAAM,CAAC;IACdxB,IAAI,EAAE,OAAO;IACb0B,MAAM;IACNd,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQ+E,MAAM,CAACE,QAAQ,CAACjF,KAAK,CAAC,IAC1B,qBAAqBgF,WAAW,qBAAqBjF,KAAK,CAACC,KAAK,CAAC,EAAE;IAC3E;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASkF,IAAIA,CAAA,EAAG;EACZ,OAAO9B,MAAM,CAAC,MAAM,EAAGpD,KAAK,IAAK;IAC7B,OAAQ,OAAOA,KAAK,KAAK,UAAU,IAC/B,sCAAsCD,KAAK,CAACC,KAAK,CAAC,EAAE;EAC5D,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASmF,QAAQA,CAACC,KAAK,EAAE;EACrB,OAAOhC,MAAM,CAAC,UAAU,EAAGpD,KAAK,IAAK;IACjC,OAAQA,KAAK,YAAYoF,KAAK,IAC1B,gBAAgBA,KAAK,CAACnG,IAAI,8BAA8Bc,KAAK,CAACC,KAAK,CAAC,EAAE;EAC9E,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASqF,OAAOA,CAAA,EAAG;EACf,OAAOjC,MAAM,CAAC,SAAS,EAAGpD,KAAK,IAAK;IAChC,OAAS,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAAC4E,KAAK,CAAC5E,KAAK,CAAC,IAAIsF,MAAM,CAACC,SAAS,CAACvF,KAAK,CAAC,IAC1E,sCAAsCD,KAAK,CAACC,KAAK,CAAC,EAAE;EAC5D,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASwF,YAAYA,CAACzC,OAAO,EAAE;EAC3B,OAAO,IAAIV,MAAM,CAAC;IACdxB,IAAI,EAAE,cAAc;IACpB0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAEsB,GAAG,EAAE;MACjB,KAAK,MAAMmE,CAAC,IAAI1C,OAAO,EAAE;QACrB,OAAO0C,CAAC,CAAC5D,OAAO,CAAC7B,KAAK,EAAEsB,GAAG,CAAC;MAChC;IACJ,CAAC;IACD,CAACG,SAASA,CAACzB,KAAK,EAAEsB,GAAG,EAAE;MACnB,KAAK,MAAMmE,CAAC,IAAI1C,OAAO,EAAE;QACrB,OAAO0C,CAAC,CAAChE,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;MAClC;IACJ,CAAC;IACD,CAACc,OAAOA,CAACpC,KAAK,EAAEsB,GAAG,EAAE;MACjB,KAAK,MAAMmE,CAAC,IAAI1C,OAAO,EAAE;QACrB,OAAO0C,CAAC,CAACrD,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;MAChC;IACJ;EACJ,CAAC,CAAC;AACN;AACA,SAASoE,OAAOA,CAACC,QAAQ,EAAE;EACvB,MAAMX,WAAW,GAAGjF,KAAK,CAAC4F,QAAQ,CAAC;EACnC,MAAM5D,CAAC,GAAG,OAAO4D,QAAQ;EACzB,OAAO,IAAItD,MAAM,CAAC;IACdxB,IAAI,EAAE,SAAS;IACf0B,MAAM,EAAER,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,QAAQ,IAAIA,CAAC,KAAK,SAAS,GAAG4D,QAAQ,GAAG,IAAI;IAC7ElE,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQA,KAAK,KAAK2F,QAAQ,IACtB,0BAA0BX,WAAW,qBAAqBjF,KAAK,CAACC,KAAK,CAAC,EAAE;IAChF;EACJ,CAAC,CAAC;AACN;AACA,SAASkD,GAAGA,CAAC0C,GAAG,EAAEC,KAAK,EAAE;EACrB,OAAO,IAAIxD,MAAM,CAAC;IACdxB,IAAI,EAAE,KAAK;IACX0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAI4F,GAAG,IAAIC,KAAK,IAAI7F,KAAK,YAAYgC,GAAG,EAAE;QACtC,KAAK,MAAM,CAACN,CAAC,EAAEC,CAAC,CAAC,IAAI3B,KAAK,CAAC6B,OAAO,CAAC,CAAC,EAAE;UAClC,MAAM,CAACH,CAAC,EAAEA,CAAC,EAAEkE,GAAG,CAAC;UACjB,MAAM,CAAClE,CAAC,EAAEC,CAAC,EAAEkE,KAAK,CAAC;QACvB;MACJ;IACJ,CAAC;IACDtE,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOA,KAAK,YAAYgC,GAAG,GAAG,IAAIA,GAAG,CAAChC,KAAK,CAAC,GAAGA,KAAK;IACxD,CAAC;IACDyB,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQA,KAAK,YAAYgC,GAAG,IACxB,4CAA4CjC,KAAK,CAACC,KAAK,CAAC,EAAE;IAClE;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS8F,KAAKA,CAAA,EAAG;EACb,OAAO1C,MAAM,CAAC,OAAO,EAAE,MAAM,KAAK,CAAC;AACvC;AACA;AACA;AACA;AACA,SAAS2C,QAAQA,CAACpF,MAAM,EAAE;EACtB,OAAO,IAAI0B,MAAM,CAAC;IACd,GAAG1B,MAAM;IACTc,SAAS,EAAEA,CAACzB,KAAK,EAAEsB,GAAG,KAAKtB,KAAK,KAAK,IAAI,IAAIW,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;IACzEc,OAAO,EAAEA,CAACpC,KAAK,EAAEsB,GAAG,KAAKtB,KAAK,KAAK,IAAI,IAAIW,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG;EACxE,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS0E,MAAMA,CAAA,EAAG;EACd,OAAO5C,MAAM,CAAC,QAAQ,EAAGpD,KAAK,IAAK;IAC/B,OAAS,OAAOA,KAAK,KAAK,QAAQ,IAAI,CAAC4E,KAAK,CAAC5E,KAAK,CAAC,IAC/C,oCAAoCD,KAAK,CAACC,KAAK,CAAC,EAAE;EAC1D,CAAC,CAAC;AACN;AACA,SAASmD,MAAMA,CAACZ,MAAM,EAAE;EACpB,MAAM0D,MAAM,GAAG1D,MAAM,GAAGxD,MAAM,CAAC4E,IAAI,CAACpB,MAAM,CAAC,GAAG,EAAE;EAChD,MAAM2D,KAAK,GAAGJ,KAAK,CAAC,CAAC;EACrB,OAAO,IAAIzD,MAAM,CAAC;IACdxB,IAAI,EAAE,QAAQ;IACd0B,MAAM,EAAEA,MAAM,GAAGA,MAAM,GAAG,IAAI;IAC9B,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIuC,MAAM,IAAInD,QAAQ,CAACY,KAAK,CAAC,EAAE;QAC3B,MAAMmG,QAAQ,GAAG,IAAIjE,GAAG,CAACnD,MAAM,CAAC4E,IAAI,CAAC3D,KAAK,CAAC,CAAC;QAC5C,KAAK,MAAMe,GAAG,IAAIkF,MAAM,EAAE;UACtBE,QAAQ,CAACC,MAAM,CAACrF,GAAG,CAAC;UACpB,MAAM,CAACA,GAAG,EAAEf,KAAK,CAACe,GAAG,CAAC,EAAEwB,MAAM,CAACxB,GAAG,CAAC,CAAC;QACxC;QACA,KAAK,MAAMA,GAAG,IAAIoF,QAAQ,EAAE;UACxB,MAAM,CAACpF,GAAG,EAAEf,KAAK,CAACe,GAAG,CAAC,EAAEmF,KAAK,CAAC;QAClC;MACJ;IACJ,CAAC;IACDzE,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQT,gBAAgB,CAACS,KAAK,CAAC,IAC3B,qCAAqCD,KAAK,CAACC,KAAK,CAAC,EAAE;IAC3D,CAAC;IACDuB,OAAOA,CAACvB,KAAK,EAAEsB,GAAG,EAAE;MAChB,IAAI,CAAC/B,gBAAgB,CAACS,KAAK,CAAC,EAAE;QAC1B,OAAOA,KAAK;MAChB;MACA,MAAMqG,OAAO,GAAG;QAAE,GAAGrG;MAAM,CAAC;MAC5B;MACA;MACA;MACA,IAAIsB,GAAG,CAACD,IAAI,IAAIkB,MAAM,EAAE;QACpB,KAAK,MAAMxB,GAAG,IAAIsF,OAAO,EAAE;UACvB,IAAI9D,MAAM,CAACxB,GAAG,CAAC,KAAKR,SAAS,EAAE;YAC3B,OAAO8F,OAAO,CAACtF,GAAG,CAAC;UACvB;QACJ;MACJ;MACA,OAAOsF,OAAO;IAClB;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAStC,QAAQA,CAACpD,MAAM,EAAE;EACtB,OAAO,IAAI0B,MAAM,CAAC;IACd,GAAG1B,MAAM;IACTc,SAAS,EAAEA,CAACzB,KAAK,EAAEsB,GAAG,KAAKtB,KAAK,KAAKO,SAAS,IAAII,MAAM,CAACc,SAAS,CAACzB,KAAK,EAAEsB,GAAG,CAAC;IAC9Ec,OAAO,EAAEA,CAACpC,KAAK,EAAEsB,GAAG,KAAKtB,KAAK,KAAKO,SAAS,IAAII,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG;EAC7E,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgF,MAAMA,CAACV,GAAG,EAAEC,KAAK,EAAE;EACxB,OAAO,IAAIxD,MAAM,CAAC;IACdxB,IAAI,EAAE,QAAQ;IACd0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIZ,QAAQ,CAACY,KAAK,CAAC,EAAE;QACjB,KAAK,MAAM0B,CAAC,IAAI1B,KAAK,EAAE;UACnB,MAAM2B,CAAC,GAAG3B,KAAK,CAAC0B,CAAC,CAAC;UAClB,MAAM,CAACA,CAAC,EAAEA,CAAC,EAAEkE,GAAG,CAAC;UACjB,MAAM,CAAClE,CAAC,EAAEC,CAAC,EAAEkE,KAAK,CAAC;QACvB;MACJ;IACJ,CAAC;IACDpE,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQT,gBAAgB,CAACS,KAAK,CAAC,IAC3B,qCAAqCD,KAAK,CAACC,KAAK,CAAC,EAAE;IAC3D,CAAC;IACDuB,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOT,gBAAgB,CAACS,KAAK,CAAC,GAAG;QAAE,GAAGA;MAAM,CAAC,GAAGA,KAAK;IACzD;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASuG,MAAMA,CAAA,EAAG;EACd,OAAOnD,MAAM,CAAC,QAAQ,EAAGpD,KAAK,IAAK;IAC/B,OAAOA,KAAK,YAAYwG,MAAM;EAClC,CAAC,CAAC;AACN;AACA,SAASvE,GAAGA,CAACoC,OAAO,EAAE;EAClB,OAAO,IAAIhC,MAAM,CAAC;IACdxB,IAAI,EAAE,KAAK;IACX0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIqE,OAAO,IAAIrE,KAAK,YAAYkC,GAAG,EAAE;QACjC,KAAK,MAAMP,CAAC,IAAI3B,KAAK,EAAE;UACnB,MAAM,CAAC2B,CAAC,EAAEA,CAAC,EAAE0C,OAAO,CAAC;QACzB;MACJ;IACJ,CAAC;IACD9C,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOA,KAAK,YAAYkC,GAAG,GAAG,IAAIA,GAAG,CAAClC,KAAK,CAAC,GAAGA,KAAK;IACxD,CAAC;IACDyB,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQA,KAAK,YAAYkC,GAAG,IACxB,4CAA4CnC,KAAK,CAACC,KAAK,CAAC,EAAE;IAClE;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASyG,MAAMA,CAAA,EAAG;EACd,OAAOrD,MAAM,CAAC,QAAQ,EAAGpD,KAAK,IAAK;IAC/B,OAAQ,OAAOA,KAAK,KAAK,QAAQ,IAC7B,oCAAoCD,KAAK,CAACC,KAAK,CAAC,EAAE;EAC1D,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA,SAAS6C,KAAKA,CAACE,OAAO,EAAE;EACpB,MAAMmD,KAAK,GAAGJ,KAAK,CAAC,CAAC;EACrB,OAAO,IAAIzD,MAAM,CAAC;IACdxB,IAAI,EAAE,OAAO;IACb0B,MAAM,EAAE,IAAI;IACZ,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,EAAE;QACtB,MAAMpB,MAAM,GAAG8H,IAAI,CAACC,GAAG,CAAC5D,OAAO,CAACnE,MAAM,EAAEoB,KAAK,CAACpB,MAAM,CAAC;QACrD,KAAK,IAAI0F,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG1F,MAAM,EAAE0F,CAAC,EAAE,EAAE;UAC7B,MAAM,CAACA,CAAC,EAAEtE,KAAK,CAACsE,CAAC,CAAC,EAAEvB,OAAO,CAACuB,CAAC,CAAC,IAAI4B,KAAK,CAAC;QAC5C;MACJ;IACJ,CAAC;IACDzE,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,IACxB,oCAAoCD,KAAK,CAACC,KAAK,CAAC,EAAE;IAC1D,CAAC;IACDuB,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOR,KAAK,CAACC,OAAO,CAACO,KAAK,CAAC,GAAGA,KAAK,CAACuE,KAAK,CAAC,CAAC,GAAGvE,KAAK;IACvD;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASa,IAAIA,CAAC0B,MAAM,EAAE;EAClB,MAAMoB,IAAI,GAAG5E,MAAM,CAAC4E,IAAI,CAACpB,MAAM,CAAC;EAChC,OAAO,IAAIF,MAAM,CAAC;IACdxB,IAAI,EAAE,MAAM;IACZ0B,MAAM;IACN,CAACV,OAAOA,CAAC7B,KAAK,EAAE;MACZ,IAAIZ,QAAQ,CAACY,KAAK,CAAC,EAAE;QACjB,KAAK,MAAM0B,CAAC,IAAIiC,IAAI,EAAE;UAClB,MAAM,CAACjC,CAAC,EAAE1B,KAAK,CAAC0B,CAAC,CAAC,EAAEa,MAAM,CAACb,CAAC,CAAC,CAAC;QAClC;MACJ;IACJ,CAAC;IACDD,SAASA,CAACzB,KAAK,EAAE;MACb,OAAQT,gBAAgB,CAACS,KAAK,CAAC,IAC3B,qCAAqCD,KAAK,CAACC,KAAK,CAAC,EAAE;IAC3D,CAAC;IACDuB,OAAOA,CAACvB,KAAK,EAAE;MACX,OAAOT,gBAAgB,CAACS,KAAK,CAAC,GAAG;QAAE,GAAGA;MAAM,CAAC,GAAGA,KAAK;IACzD;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS4G,KAAKA,CAAC7D,OAAO,EAAE;EACpB,MAAMiC,WAAW,GAAGjC,OAAO,CAACG,GAAG,CAAEtB,CAAC,IAAKA,CAAC,CAACf,IAAI,CAAC,CAAChC,IAAI,CAAC,KAAK,CAAC;EAC1D,OAAO,IAAIwD,MAAM,CAAC;IACdxB,IAAI,EAAE,OAAO;IACb0B,MAAM,EAAE,IAAI;IACZhB,OAAOA,CAACvB,KAAK,EAAEsB,GAAG,EAAE;MAChB,KAAK,MAAMmE,CAAC,IAAI1C,OAAO,EAAE;QACrB,MAAM,CAACD,KAAK,EAAEuD,OAAO,CAAC,GAAGZ,CAAC,CAAC9C,QAAQ,CAAC3C,KAAK,EAAE;UACvCoB,MAAM,EAAE,IAAI;UACZC,IAAI,EAAEC,GAAG,CAACD;QACd,CAAC,CAAC;QACF,IAAI,CAACyB,KAAK,EAAE;UACR,OAAOuD,OAAO;QAClB;MACJ;MACA,OAAOrG,KAAK;IAChB,CAAC;IACDyB,SAASA,CAACzB,KAAK,EAAEsB,GAAG,EAAE;MAClB,MAAMjD,QAAQ,GAAG,EAAE;MACnB,KAAK,MAAMoH,CAAC,IAAI1C,OAAO,EAAE;QACrB,MAAM,CAAC,GAAGH,MAAM,CAAC,GAAG1B,GAAG,CAAClB,KAAK,EAAEyF,CAAC,EAAEnE,GAAG,CAAC;QACtC,MAAM,CAACuF,KAAK,CAAC,GAAGjE,MAAM;QACtB,IAAI,CAACiE,KAAK,CAAC,CAAC,CAAC,EAAE;UACX,OAAO,EAAE;QACb,CAAC,MACI;UACD,KAAK,MAAM,CAACzI,OAAO,CAAC,IAAIwE,MAAM,EAAE;YAC5B,IAAIxE,OAAO,EAAE;cACTC,QAAQ,CAACyI,IAAI,CAAC1I,OAAO,CAAC;YAC1B;UACJ;QACJ;MACJ;MACA,OAAO,CACH,8CAA8C4G,WAAW,qBAAqBjF,KAAK,CAACC,KAAK,CAAC,EAAE,EAC5F,GAAG3B,QAAQ,CACd;IACL;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS0I,OAAOA,CAAA,EAAG;EACf,OAAO3D,MAAM,CAAC,SAAS,EAAE,MAAM,IAAI,CAAC;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAShC,MAAMA,CAACT,MAAM,EAAEqG,SAAS,EAAEzF,OAAO,EAAE;EACxC,OAAO,IAAIc,MAAM,CAAC;IACd,GAAG1B,MAAM;IACTY,OAAO,EAAEA,CAACvB,KAAK,EAAEsB,GAAG,KAAK;MACrB,OAAOoB,EAAE,CAAC1C,KAAK,EAAEgH,SAAS,CAAC,GACrBrG,MAAM,CAACY,OAAO,CAACA,OAAO,CAACvB,KAAK,EAAEsB,GAAG,CAAC,EAAEA,GAAG,CAAC,GACxCX,MAAM,CAACY,OAAO,CAACvB,KAAK,EAAEsB,GAAG,CAAC;IACpC;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS2F,SAASA,CAACtG,MAAM,EAAEuG,QAAQ,EAAE/F,OAAO,GAAG,CAAC,CAAC,EAAE;EAC/C,OAAOC,MAAM,CAACT,MAAM,EAAEoG,OAAO,CAAC,CAAC,EAAG5H,CAAC,IAAK;IACpC,MAAMgI,CAAC,GAAG,OAAOD,QAAQ,KAAK,UAAU,GAAGA,QAAQ,CAAC,CAAC,GAAGA,QAAQ;IAChE,IAAI/H,CAAC,KAAKoB,SAAS,EAAE;MACjB,OAAO4G,CAAC;IACZ;IACA,IAAI,CAAChG,OAAO,CAACiG,MAAM,IAAI1H,aAAa,CAACP,CAAC,CAAC,IAAIO,aAAa,CAACyH,CAAC,CAAC,EAAE;MACzD,MAAME,GAAG,GAAG;QAAE,GAAGlI;MAAE,CAAC;MACpB,IAAImI,OAAO,GAAG,KAAK;MACnB,KAAK,MAAMvG,GAAG,IAAIoG,CAAC,EAAE;QACjB,IAAIE,GAAG,CAACtG,GAAG,CAAC,KAAKR,SAAS,EAAE;UACxB8G,GAAG,CAACtG,GAAG,CAAC,GAAGoG,CAAC,CAACpG,GAAG,CAAC;UACjBuG,OAAO,GAAG,IAAI;QAClB;MACJ;MACA,IAAIA,OAAO,EAAE;QACT,OAAOD,GAAG;MACd;IACJ;IACA,OAAOlI,CAAC;EACZ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASoI,OAAOA,CAAC5G,MAAM,EAAE;EACrB,OAAOS,MAAM,CAACT,MAAM,EAAE8F,MAAM,CAAC,CAAC,EAAGtH,CAAC,IAAKA,CAAC,CAACqI,IAAI,CAAC,CAAC,CAAC;AACpD;;AAEA;AACA;AACA;AACA,SAASC,KAAKA,CAAC9G,MAAM,EAAE;EACnB,OAAO+G,MAAM,CAAC/G,MAAM,EAAE,OAAO,EAAGX,KAAK,IAAK;IACtC,MAAM2H,IAAI,GAAGC,OAAO,CAAC5H,KAAK,CAAC;IAC3B,OAAQ2H,IAAI,KAAK,CAAC,IACd,qBAAqBhH,MAAM,CAACE,IAAI,sCAAsC8G,IAAI,IAAI;EACtF,CAAC,CAAC;AACN;AACA,SAASC,OAAOA,CAAC5H,KAAK,EAAE;EACpB,IAAIA,KAAK,YAAYgC,GAAG,IAAIhC,KAAK,YAAYkC,GAAG,EAAE;IAC9C,OAAOlC,KAAK,CAAC2H,IAAI;EACrB,CAAC,MACI;IACD,OAAO3H,KAAK,CAACpB,MAAM;EACvB;AACJ;AACA;AACA;AACA;AACA,SAAS+H,GAAGA,CAAChG,MAAM,EAAEkH,SAAS,EAAE1G,OAAO,GAAG,CAAC,CAAC,EAAE;EAC1C,MAAM;IAAE2G;EAAU,CAAC,GAAG3G,OAAO;EAC7B,OAAOuG,MAAM,CAAC/G,MAAM,EAAE,KAAK,EAAGX,KAAK,IAAK;IACpC,OAAO8H,SAAS,GACV9H,KAAK,GAAG6H,SAAS,GACjB7H,KAAK,IAAI6H,SAAS,IAChB,cAAclH,MAAM,CAACE,IAAI,cAAciH,SAAS,GAAG,EAAE,GAAG,cAAc,GAAGD,SAAS,mBAAmB7H,KAAK,IAAI;EAC1H,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS+H,GAAGA,CAACpH,MAAM,EAAEkH,SAAS,EAAE1G,OAAO,GAAG,CAAC,CAAC,EAAE;EAC1C,MAAM;IAAE2G;EAAU,CAAC,GAAG3G,OAAO;EAC7B,OAAOuG,MAAM,CAAC/G,MAAM,EAAE,KAAK,EAAGX,KAAK,IAAK;IACpC,OAAO8H,SAAS,GACV9H,KAAK,GAAG6H,SAAS,GACjB7H,KAAK,IAAI6H,SAAS,IAChB,cAAclH,MAAM,CAACE,IAAI,iBAAiBiH,SAAS,GAAG,EAAE,GAAG,cAAc,GAAGD,SAAS,mBAAmB7H,KAAK,IAAI;EAC7H,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASgI,QAAQA,CAACrH,MAAM,EAAE;EACtB,OAAO+G,MAAM,CAAC/G,MAAM,EAAE,UAAU,EAAGX,KAAK,IAAK;IACzC,MAAM2H,IAAI,GAAGC,OAAO,CAAC5H,KAAK,CAAC;IAC3B,OAAQ2H,IAAI,GAAG,CAAC,IAAI,uBAAuBhH,MAAM,CAACE,IAAI,4BAA4B;EACtF,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAASoH,OAAOA,CAACtH,MAAM,EAAE4F,MAAM,EAAE;EAC7B,OAAOmB,MAAM,CAAC/G,MAAM,EAAE,SAAS,EAAGX,KAAK,IAAK;IACxC,OAAQuG,MAAM,CAAC2B,IAAI,CAAClI,KAAK,CAAC,IACtB,cAAcW,MAAM,CAACE,IAAI,gBAAgB0F,MAAM,CAAC4B,MAAM,qBAAqBnI,KAAK,GAAG;EAC3F,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA,SAAS2H,IAAIA,CAAChH,MAAM,EAAEoH,GAAG,EAAEpB,GAAG,GAAGoB,GAAG,EAAE;EAClC,MAAMK,QAAQ,GAAG,cAAczH,MAAM,CAACE,IAAI,EAAE;EAC5C,MAAMwH,EAAE,GAAGN,GAAG,KAAKpB,GAAG,GAAG,QAAQoB,GAAG,IAAI,GAAG,aAAaA,GAAG,YAAYpB,GAAG,IAAI;EAC9E,OAAOe,MAAM,CAAC/G,MAAM,EAAE,MAAM,EAAGX,KAAK,IAAK;IACrC,IAAI,OAAOA,KAAK,KAAK,QAAQ,IAAIA,KAAK,YAAY2E,IAAI,EAAE;MACpD,OAASoD,GAAG,IAAI/H,KAAK,IAAIA,KAAK,IAAI2G,GAAG,IACjC,GAAGyB,QAAQ,IAAIC,EAAE,mBAAmBrI,KAAK,IAAI;IACrD,CAAC,MACI,IAAIA,KAAK,YAAYgC,GAAG,IAAIhC,KAAK,YAAYkC,GAAG,EAAE;MACnD,MAAM;QAAEyF;MAAK,CAAC,GAAG3H,KAAK;MACtB,OAAS+H,GAAG,IAAIJ,IAAI,IAAIA,IAAI,IAAIhB,GAAG,IAC/B,GAAGyB,QAAQ,gBAAgBC,EAAE,sCAAsCV,IAAI,IAAI;IACnF,CAAC,MACI;MACD,MAAM;QAAE/I;MAAO,CAAC,GAAGoB,KAAK;MACxB,OAAS+H,GAAG,IAAInJ,MAAM,IAAIA,MAAM,IAAI+H,GAAG,IACnC,GAAGyB,QAAQ,kBAAkBC,EAAE,wCAAwCzJ,MAAM,IAAI;IACzF;EACJ,CAAC,CAAC;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS8I,MAAMA,CAAC/G,MAAM,EAAE1B,IAAI,EAAEmD,OAAO,EAAE;EACnC,OAAO,IAAIC,MAAM,CAAC;IACd,GAAG1B,MAAM;IACT,CAACyB,OAAOA,CAACpC,KAAK,EAAEsB,GAAG,EAAE;MACjB,OAAOX,MAAM,CAACyB,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;MACjC,MAAMb,MAAM,GAAG2B,OAAO,CAACpC,KAAK,EAAEsB,GAAG,CAAC;MAClC,MAAMjD,QAAQ,GAAG2C,UAAU,CAACP,MAAM,EAAEa,GAAG,EAAEX,MAAM,EAAEX,KAAK,CAAC;MACvD,KAAK,MAAM5B,OAAO,IAAIC,QAAQ,EAAE;QAC5B,MAAM;UAAE,GAAGD,OAAO;UAAE0C,UAAU,EAAE7B;QAAK,CAAC;MAC1C;IACJ;EACJ,CAAC,CAAC;AACN;AAEA,SAASoD,MAAM,EAAEpE,WAAW,EAAEkG,GAAG,EAAEC,KAAK,EAAE5B,MAAM,EAAExD,MAAM,EAAEwF,MAAM,EAAEC,OAAO,EAAErD,MAAM,EAAEqB,MAAM,EAAEiC,IAAI,EAAEuC,SAAS,EAAE7D,MAAM,EAAEC,UAAU,EAAEE,OAAO,EAAEkE,KAAK,EAAE3C,KAAK,EAAEI,IAAI,EAAEC,QAAQ,EAAEE,OAAO,EAAEG,YAAY,EAAE9C,EAAE,EAAEe,IAAI,EAAEiC,OAAO,EAAExC,GAAG,EAAE7B,IAAI,EAAEsF,GAAG,EAAEoB,GAAG,EAAEjC,KAAK,EAAEkC,QAAQ,EAAEjC,QAAQ,EAAEC,MAAM,EAAE7C,MAAM,EAAEO,IAAI,EAAEK,QAAQ,EAAEF,OAAO,EAAEoE,OAAO,EAAEjE,IAAI,EAAEsC,MAAM,EAAEoB,MAAM,EAAEnB,MAAM,EAAEtE,GAAG,EAAE0F,IAAI,EAAElB,MAAM,EAAE9F,MAAM,EAAE4G,OAAO,EAAE1E,KAAK,EAAEhC,IAAI,EAAE+F,KAAK,EAAEG,OAAO,EAAEpE,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}