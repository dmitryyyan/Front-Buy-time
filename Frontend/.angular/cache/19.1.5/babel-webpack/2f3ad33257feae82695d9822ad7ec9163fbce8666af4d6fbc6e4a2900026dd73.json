{"ast":null,"code":"/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { Field, mod } from \"./modular.js\";\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n  validateObject(curve, {\n    a: 'bigint'\n  }, {\n    montgomeryBits: 'isSafeInteger',\n    nByteLength: 'isSafeInteger',\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    powPminus2: 'function',\n    Gu: 'bigint'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...curve\n  });\n}\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    P\n  } = CURVE;\n  const Fp = Field(P);\n  const modP = n => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || (bytes => bytes);\n  const powPminus2 = CURVE.powPminus2 || (x => Fp.pow(x, P - BigInt(2)));\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap, x_2, x_3) {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u, scalar) {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, _0n, P);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = k >> t & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n  function encodeUCoordinate(u) {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n  function decodeUCoordinate(uEnc) {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n) {\n    const bytes = ensureBytes('scalar', n);\n    const len = bytes.length;\n    if (len !== montgomeryBytes && len !== fieldLen) {\n      let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n      throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n    }\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar, u) {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar) {\n    return scalarMult(scalar, GuBytes);\n  }\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n    getPublicKey: privateKey => scalarMultBase(privateKey),\n    utils: {\n      randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength)\n    },\n    GuBytes: GuBytes\n  };\n}","map":{"version":3,"names":["Field","mod","aInRange","bytesToNumberLE","ensureBytes","numberToBytesLE","validateObject","_0n","BigInt","_1n","validateOpts","curve","a","montgomeryBits","nByteLength","adjustScalarBytes","domain","powPminus2","Gu","Object","freeze","montgomery","curveDef","CURVE","P","Fp","modP","n","montgomeryBytes","Math","ceil","fieldLen","bytes","x","pow","cswap","swap","x_2","x_3","dummy","a24","montgomeryLadder","u","scalar","k","x_1","z_2","z_3","sw","t","k_t","A","AA","B","BB","E","C","D","DA","CB","dacb","da_cb","z2","encodeUCoordinate","decodeUCoordinate","uEnc","decodeScalar","len","length","valid","Error","scalarMult","pointU","_scalar","pu","GuBytes","scalarMultBase","getSharedSecret","privateKey","publicKey","getPublicKey","utils","randomPrivateKey","randomBytes"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/montgomery.js"],"sourcesContent":["/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { Field, mod } from \"./modular.js\";\nimport { aInRange, bytesToNumberLE, ensureBytes, numberToBytesLE, validateObject, } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    validateObject(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const Fp = Field(P);\n    const modP = (n) => mod(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => Fp.pow(x, P - BigInt(2)));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(u, scalar) {\n        aInRange('u', u, _0n, P);\n        aInRange('scalar', scalar, _0n, P);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return numberToBytesLE(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return bytesToNumberLE(u);\n    }\n    function decodeScalar(n) {\n        const bytes = ensureBytes('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen) {\n            let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n            throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n        }\n        return bytesToNumberLE(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}