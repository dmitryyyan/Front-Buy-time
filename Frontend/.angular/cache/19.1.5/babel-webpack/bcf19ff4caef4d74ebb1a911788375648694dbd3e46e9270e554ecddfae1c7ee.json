{"ast":null,"code":"/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nexport function isBytes(a) {\n  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\nexport function abytes(item) {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin =\n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction asciiToBase16(ch) {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = n => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = n => (_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = len => new Uint8Array(len); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || isBytes(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n  throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n  const map = new WeakMap();\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}","map":{"version":3,"names":["_0n","BigInt","_1n","isBytes","a","Uint8Array","ArrayBuffer","isView","constructor","name","abytes","item","Error","abool","title","value","numberToHexUnpadded","num","hex","toString","length","hexToNumber","hasHexBuiltin","from","toHex","fromHex","hexes","Array","_","i","padStart","bytesToHex","bytes","asciis","_0","_9","A","F","f","asciiToBase16","ch","hexToBytes","hl","al","array","ai","hi","n1","charCodeAt","n2","undefined","char","bytesToNumberBE","bytesToNumberLE","reverse","numberToBytesBE","n","len","numberToBytesLE","numberToVarBytesBE","ensureBytes","expectedLength","res","e","concatBytes","arrays","sum","pad","set","equalBytes","b","diff","utf8ToBytes","str","TextEncoder","encode","isPosBig","inRange","min","max","aInRange","bitLen","bitGet","pos","bitSet","bitMask","u8n","u8fr","arr","createHmacDrbg","hashLen","qByteLen","hmacFn","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","isArray","field","object","Fp","isValid","hash","outputLen","validateObject","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries","notImplemented","memoized","fn","map","WeakMap","arg","args","get","computed"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/utils.js"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport function isBytes(a) {\n    return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\nexport function abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\nexport function abool(title, value) {\n    if (typeof value !== 'boolean')\n        throw new Error(title + ' boolean expected, got ' + value);\n}\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? '0' + hex : hex;\n}\nexport function hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin = \n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes) {\n    abytes(bytes);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return bytes.toHex();\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\nfunction asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n        return ch - asciis._0; // '2' => 50-48\n    if (ch >= asciis.A && ch <= asciis.F)\n        return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n    if (ch >= asciis.a && ch <= asciis.f)\n        return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n    return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // @ts-ignore\n    if (hasHexBuiltin)\n        return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nexport function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(title + ' must be hex string or Uint8Array');\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error('string expected');\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = (n) => typeof n === 'bigint' && _0n <= n;\nexport function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max))\n        throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n) => (_1n << BigInt(n)) - _1n;\n// DRBG\nconst u8n = (len) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0)) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nexport function validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error('invalid validator function');\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nexport const notImplemented = () => {\n    throw new Error('not implemented');\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args) => {\n        const val = map.get(arg);\n        if (val !== undefined)\n            return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}