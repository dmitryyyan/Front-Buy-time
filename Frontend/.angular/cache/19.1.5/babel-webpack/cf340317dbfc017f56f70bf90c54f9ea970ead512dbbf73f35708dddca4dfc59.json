{"ast":null,"code":"/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite Field over which we'll do calculations. Can be complex (Fp2, Fp12)\n * * n: Curve prime subgroup order, total count of valid points in the field\n * * Gx: Base point (x, y) aka generator point x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\n// prettier-ignore\nimport { Field, FpInvertBatch, getMinHashLength, invert, mapHashToField, mod, validateField } from \"./modular.js\";\n// prettier-ignore\nimport { aInRange, abool, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToBytesBE, numberToHexUnpadded, validateObject } from \"./utils.js\";\nfunction validateSigVerOpts(opts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n  const opts = validateBasic(curve);\n  validateObject(opts, {\n    a: 'field',\n    b: 'field'\n  }, {\n    allowedPrivateKeyLengths: 'array',\n    wrapPrivateKey: 'boolean',\n    isTorsionFree: 'function',\n    clearCofactor: 'function',\n    allowInfinityPoint: 'boolean',\n    fromBytes: 'function',\n    toBytes: 'function'\n  });\n  const {\n    endo,\n    Fp,\n    a\n  } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n    }\n    if (typeof endo !== 'object' || typeof endo.beta !== 'bigint' || typeof endo.splitScalar !== 'function') {\n      throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({\n    ...opts\n  });\n}\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag, data) => {\n      const {\n        Err: E\n      } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = numberToHexUnpadded(dataLen);\n      if (len.length / 2 & 128) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : '';\n      const t = numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag, data) {\n      const {\n        Err: E\n      } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 127;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = length << 8 | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return {\n        v,\n        l: data.subarray(pos + length)\n      };\n    }\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num) {\n      const {\n        Err: E\n      } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data) {\n      const {\n        Err: E\n      } = DER;\n      if (data[0] & 128) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 128)) throw new E('invalid signature integer: unnecessary leading zero');\n      return bytesToNumberBE(data);\n    }\n  },\n  toSig(hex) {\n    // parse DER signature\n    const {\n      Err: E,\n      _int: int,\n      _tlv: tlv\n    } = DER;\n    const data = ensureBytes('signature', hex);\n    const {\n      v: seqBytes,\n      l: seqLeftBytes\n    } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const {\n      v: rBytes,\n      l: rLeftBytes\n    } = tlv.decode(0x02, seqBytes);\n    const {\n      v: sBytes,\n      l: sLeftBytes\n    } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return {\n      r: int.decode(rBytes),\n      s: int.decode(sBytes)\n    };\n  },\n  hexFromSig(sig) {\n    const {\n      _tlv: tlv,\n      _int: int\n    } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _3n = BigInt(3),\n  _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n  const CURVE = validatePointOpts(opts);\n  const {\n    Fp\n  } = CURVE; // All curves has same field / group length as for now, but they can differ\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n  const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {\n    const a = point.toAffine();\n    return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n  });\n  const fromBytes = CURVE.fromBytes || (bytes => {\n    // const head = bytes[0];\n    const tail = bytes.subarray(1);\n    // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n    return {\n      x,\n      y\n    };\n  });\n  /**\n   * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n   * @returns y²\n   */\n  function weierstrassEquation(x) {\n    const {\n      a,\n      b\n    } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx))) throw new Error('bad generator point: equation left != right');\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num) {\n    return inRange(num, _1n, CURVE.n);\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key) {\n    const {\n      allowedPrivateKeyLengths: lengths,\n      nByteLength,\n      wrapPrivateKey,\n      n: N\n    } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (isBytes(key)) key = bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length)) throw new Error('invalid private key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num;\n    try {\n      num = typeof key === 'bigint' ? key : bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n    }\n    if (wrapPrivateKey) num = mod(num, N); // disabled by default, enabled for BLS\n    aInRange('private key', num, _1n, N); // num in range [1..N-1]\n    return num;\n  }\n  function aprjpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (x, y, z) ∋ (x=x/z, y=y/z)\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      px: x,\n      py: y,\n      pz: z\n    } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return {\n      x,\n      y\n    };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return {\n      x: Fp.ZERO,\n      y: Fp.ZERO\n    };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized(p => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const {\n      x,\n      y\n    } = p.toAffine();\n    // Check if x, y are valid field elements\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n    const left = Fp.sqr(y); // y²\n    const right = weierstrassEquation(x); // x³ + ax + b\n    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point {\n    constructor(px, py, pz) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py) || Fp.is0(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n      this.px = px;\n      this.py = py;\n      this.pz = pz;\n      Object.freeze(this);\n    }\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p) {\n      const {\n        x,\n        y\n      } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = i => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points) {\n      const toInv = FpInvertBatch(Fp, points.map(p => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex) {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n    // Multiscalar Multiplication\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // A point on curve is valid if it conforms to equation.\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    hasEvenY() {\n      const {\n        y\n      } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n    /**\n     * Compare one point to another.\n     */\n    equals(other) {\n      aprjpoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate() {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const {\n        a,\n        b\n      } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other) {\n      aprjpoint(other);\n      const {\n        px: X1,\n        py: Y1,\n        pz: Z1\n      } = this;\n      const {\n        px: X2,\n        py: Y2,\n        pz: Z2\n      } = other;\n      let X3 = Fp.ZERO,\n        Y3 = Fp.ZERO,\n        Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    wNAF(n) {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc) {\n      const {\n        endo,\n        n: N\n      } = CURVE;\n      aInRange('scalar', sc, _0n, N);\n      const I = Point.ZERO;\n      if (sc === _0n) return I;\n      if (this.is0() || sc === _1n) return this;\n      // Case a: no endomorphism. Case b: has precomputes.\n      if (!endo || wnaf.hasPrecomputes(this)) return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n      // Case c: endomorphism\n      let {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n      } = endo.splitScalar(sc);\n      let k1p = I;\n      let k2p = I;\n      let d = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar) {\n      const {\n        endo,\n        n: N\n      } = CURVE;\n      aInRange('scalar', scalar, _1n, N);\n      let point, fake; // Fake point is used to const-time mult\n      if (endo) {\n        const {\n          k1neg,\n          k1,\n          k2neg,\n          k2\n        } = endo.splitScalar(scalar);\n        let {\n          p: k1p,\n          f: f1p\n        } = this.wNAF(k1);\n        let {\n          p: k2p,\n          f: f2p\n        } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const {\n          p,\n          f\n        } = this.wNAF(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q, a, b) {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (P, a // Select faster multiply() method\n      ) => a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a);\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    toAffine(iz) {\n      return toAffineMemo(this, iz);\n    }\n    isTorsionFree() {\n      const {\n        h: cofactor,\n        isTorsionFree\n      } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor() {\n      const {\n        h: cofactor,\n        clearCofactor\n      } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this);\n      return this.multiplyUnsafe(CURVE.h);\n    }\n    toRawBytes(isCompressed = true) {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n    toHex(isCompressed = true) {\n      abool('isCompressed', isCompressed);\n      return bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  return {\n    CURVE,\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  };\n}\nfunction validateOpts(curve) {\n  const opts = validateBasic(curve);\n  validateObject(opts, {\n    hash: 'hash',\n    hmac: 'function',\n    randomBytes: 'function'\n  }, {\n    bits2int: 'function',\n    bits2int_modN: 'function',\n    lowS: 'boolean'\n  });\n  return Object.freeze({\n    lowS: true,\n    ...opts\n  });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    Fp,\n    n: CURVE_ORDER\n  } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n  function modN(a) {\n    return mod(a, CURVE_ORDER);\n  }\n  function invN(a) {\n    return invert(a, CURVE_ORDER);\n  }\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed) {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = concatBytes;\n      abool('isCompressed', isCompressed);\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = bytesToNumberBE(tail);\n        if (!inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n        let y;\n        try {\n          y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n        } catch (sqrtError) {\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n          throw new Error('Point is not on curve' + suffix);\n        }\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return {\n          x,\n          y\n        };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return {\n          x,\n          y\n        };\n      } else {\n        const cl = compressedLen;\n        const ul = uncompressedLen;\n        throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n      }\n    }\n  });\n  const numToNByteHex = num => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));\n  function isBiggerThanHalfOrder(number) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n  function normalizeS(s) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature {\n    constructor(r, s, recovery) {\n      aInRange('r', r, _1n, CURVE_ORDER); // r in [1..N]\n      aInRange('s', s, _1n, CURVE_ORDER); // s in [1..N]\n      this.r = r;\n      this.s = s;\n      if (recovery != null) this.recovery = recovery;\n      Object.freeze(this);\n    }\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex) {\n      const {\n        r,\n        s\n      } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n    /**\n     * @todo remove\n     * @deprecated\n     */\n    assertValidity() {}\n    addRecoveryBit(recovery) {\n      return new Signature(this.r, this.s, recovery);\n    }\n    recoverPublicKey(msgHash) {\n      const {\n        r,\n        s,\n        recovery: rec\n      } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteHex(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS() {\n      return isBiggerThanHalfOrder(this.s);\n    }\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n    // DER-encoded\n    toDERRawBytes() {\n      return hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig(this);\n    }\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteHex(this.r) + numToNByteHex(this.s);\n    }\n  }\n  const utils = {\n    isValidPrivateKey(privateKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: () => {\n      const length = getMinHashLength(CURVE.n);\n      return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE) {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    }\n  };\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey, isCompressed = true) {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item) {\n    const arr = isBytes(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && item.length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA, publicB, isCompressed = true) {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int = CURVE.bits2int || function (bytes) {\n    // Our custom check \"just in case\"\n    if (bytes.length > 8192) throw new Error('input is too large');\n    // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n    // for some cases, since bytes.length * 8 is not actual bitLength.\n    const num = bytesToNumberBE(bytes); // check for == u8 done here\n    const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n    return delta > 0 ? num >> BigInt(delta) : num;\n  };\n  const bits2int_modN = CURVE.bits2int_modN || function (bytes) {\n    return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n  };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num) {\n    aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n    // works with order, can have different size than numToField!\n    return numberToBytesBE(num, CURVE.nByteLength);\n  }\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some(k => k in opts)) throw new Error('sign() legacy options not supported');\n    const {\n      hash,\n      randomBytes\n    } = CURVE;\n    let {\n      lowS,\n      prehash,\n      extraEntropy: ent\n    } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes) {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery); // use normS, not s\n    }\n    return {\n      seed,\n      k2sig\n    };\n  }\n  const defaultSigOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  const defaultVerOpts = {\n    lowS: CURVE.lowS,\n    prehash: false\n  };\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G × k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash, privKey, opts = defaultSigOpts) {\n    const {\n      seed,\n      k2sig\n    } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1⋅G - U2⋅P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    const {\n      lowS,\n      prehash,\n      format\n    } = opts;\n    // Verify opts, deduce signature format\n    validateSigVerOpts(opts);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    if (format !== undefined && format !== 'compact' && format !== 'der') throw new Error('format must be compact or der');\n    const isHex = typeof sg === 'string' || isBytes(sg);\n    const isObj = !isHex && !format && typeof sg === 'object' && sg !== null && typeof sg.r === 'bigint' && typeof sg.s === 'bigint';\n    if (!isHex && !isObj) throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n    let _sig = undefined;\n    let P;\n    try {\n      if (isObj) _sig = new Signature(sg.r, sg.s);\n      if (isHex) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const {\n      r,\n      s\n    } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils\n  };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u, v) => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return {\n      isValid: isQR,\n      value: tv3\n    };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u, v) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return {\n        isValid: isQR,\n        value: y\n      }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n  validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z)) throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return u => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const {\n      isValid,\n      value\n    } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n    x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n    return {\n      x,\n      y\n    };\n  };\n}","map":{"version":3,"names":["pippenger","validateBasic","wNAF","Field","FpInvertBatch","getMinHashLength","invert","mapHashToField","mod","validateField","aInRange","abool","bitMask","bytesToHex","bytesToNumberBE","concatBytes","createHmacDrbg","ensureBytes","hexToBytes","inRange","isBytes","memoized","numberToBytesBE","numberToHexUnpadded","validateObject","validateSigVerOpts","opts","lowS","undefined","prehash","validatePointOpts","curve","a","b","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","clearCofactor","allowInfinityPoint","fromBytes","toBytes","endo","Fp","eql","ZERO","Error","beta","splitScalar","Object","freeze","DERErr","constructor","m","DER","Err","_tlv","encode","tag","data","E","length","dataLen","len","lenLen","t","decode","pos","first","isLong","lengthBytes","subarray","v","l","_int","num","_0n","hex","Number","parseInt","toSig","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","r","s","hexFromSig","sig","rs","ss","seq","BigInt","_1n","_2n","_3n","_4n","weierstrassPoints","CURVE","Fn","n","nBitLength","_c","point","_isCompressed","toAffine","Uint8Array","from","x","y","bytes","tail","BYTES","weierstrassEquation","x2","sqr","x3","mul","add","Gy","Gx","isWithinCurveOrder","normPrivateKeyToScalar","key","lengths","nByteLength","N","includes","padStart","error","aprjpoint","other","Point","toAffineMemo","p","iz","px","py","pz","z","ONE","is0","inv","ax","ay","zz","assertValidMemo","isValid","left","right","fromAffine","i","normalizeZ","points","toInv","map","fromHex","P","assertValidity","fromPrivateKey","privateKey","BASE","multiply","msm","scalars","_setWindowSize","windowSize","wnaf","setWindowSize","hasEvenY","isOdd","equals","X1","Y1","Z1","X2","Y2","Z2","U1","U2","negate","neg","double","b3","X3","Y3","Z3","t0","t1","t2","t3","sub","t4","t5","subtract","wNAFCached","multiplyUnsafe","sc","I","hasPrecomputes","wNAFCachedUnsafe","k1neg","k1","k2neg","k2","k1p","k2p","d","scalar","fake","f","f1p","f2p","constTimeNegate","multiplyAndAddUnsafe","Q","G","sum","h","cofactor","toRawBytes","isCompressed","toHex","_bits","Math","ceil","ProjectivePoint","validateOpts","hash","hmac","randomBytes","bits2int","bits2int_modN","weierstrass","curveDef","CURVE_ORDER","compressedLen","uncompressedLen","modN","invN","cat","head","ORDER","y2","sqrt","sqrtError","suffix","message","isYOdd","isHeadOdd","cl","ul","numToNByteHex","isBiggerThanHalfOrder","number","HALF","normalizeS","slcNum","to","slice","Signature","recovery","fromCompact","fromDER","addRecoveryBit","recoverPublicKey","msgHash","rec","radj","prefix","R","ir","u1","u2","hasHighS","toDERRawBytes","toDERHex","toCompactRawBytes","toCompactHex","utils","isValidPrivateKey","randomPrivateKey","precompute","getPublicKey","isProbPub","item","arr","str","getSharedSecret","privateA","publicB","delta","ORDER_MASK","int2octets","prepSig","defaultSigOpts","some","k","extraEntropy","ent","h1int","seedArgs","e","push","seed","k2sig","kBytes","ik","q","normS","defaultVerOpts","sign","privKey","C","drbg","outputLen","verify","signature","publicKey","sg","format","isHex","isObj","_sig","derError","is","SWUFpSqrtRatio","Z","o","c1","_2n_pow_c1_1","_2n_pow_c1","c2","c3","c4","c5","c6","pow","c7","sqrtRatio","u","tv1","tv2","tv3","tv5","tv4","isQR","cmov","tvv5","e1","value","y1","mapToCurveSimpleSWU","A","B","tv6","tv4_inv"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/weierstrass.js"],"sourcesContent":["/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Parameters\n *\n * To initialize a weierstrass curve, one needs to pass following params:\n *\n * * a: formula param\n * * b: formula param\n * * Fp: finite Field over which we'll do calculations. Can be complex (Fp2, Fp12)\n * * n: Curve prime subgroup order, total count of valid points in the field\n * * Gx: Base point (x, y) aka generator point x coordinate\n * * Gy: ...y coordinate\n * * h: cofactor, usually 1. h*n = curve group order (n is only subgroup order)\n * * lowS: whether to enable (default) or disable \"low-s\" non-malleable signatures\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\n// prettier-ignore\nimport { Field, FpInvertBatch, getMinHashLength, invert, mapHashToField, mod, validateField } from \"./modular.js\";\n// prettier-ignore\nimport { aInRange, abool, bitMask, bytesToHex, bytesToNumberBE, concatBytes, createHmacDrbg, ensureBytes, hexToBytes, inRange, isBytes, memoized, numberToBytesBE, numberToHexUnpadded, validateObject } from \"./utils.js\";\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        abool('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        abool('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nexport class DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return bytesToNumberBE(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = ensureBytes('signature', hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nexport function weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (isBytes(key))\n                key = bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = mod(num, N); // disabled by default, enabled for BLS\n        aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = memoized((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = memoized((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py) || Fp.is0(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = FpInvertBatch(Fp, points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            abool('isCompressed', isCompressed);\n            return bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    const _bits = CURVE.nBitLength;\n    const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = concatBytes;\n            abool('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = bytesToNumberBE(tail);\n                if (!inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteHex = (num) => bytesToHex(numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            aInRange('r', r, _1n, CURVE_ORDER); // r in [1..N]\n            aInRange('s', s, _1n, CURVE_ORDER); // s in [1..N]\n            this.r = r;\n            this.s = s;\n            if (recovery != null)\n                this.recovery = recovery;\n            Object.freeze(this);\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = ensureBytes('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig(ensureBytes('DER', hex));\n            return new Signature(r, s);\n        }\n        /**\n         * @todo remove\n         * @deprecated\n         */\n        assertValidity() { }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteHex(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig(this);\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteHex(this.r) + numToNByteHex(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = getMinHashLength(CURVE.n);\n            return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = ensureBytes('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n        }\n        const seed = concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = ensureBytes('msgHash', msgHash);\n        publicKey = ensureBytes('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU(Fp, opts) {\n    validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = FpInvertBatch(Fp, [tv4], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}