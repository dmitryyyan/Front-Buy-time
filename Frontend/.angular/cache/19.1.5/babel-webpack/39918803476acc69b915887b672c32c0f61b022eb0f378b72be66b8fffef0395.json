{"ast":null,"code":"/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { anumber } from '@noble/hashes/utils';\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject } from \"./utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = /* @__PURE__ */BigInt(2),\n  _3n = /* @__PURE__ */BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */BigInt(4),\n  _5n = /* @__PURE__ */BigInt(5),\n  _8n = /* @__PURE__ */BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */BigInt(9),\n  _16n = /* @__PURE__ */BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = res * num % modulo;\n    num = num * num % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n  // Do expensive precomputation step\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p-1 == q*(2^s) with q odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (Z < P && FpIsSquare(_Fp, Z)) {\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow(Fp, n) {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (!FpIsSquare(Fp, n)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: test on Fp2 and others\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n    while (!Fp.eql(b, Fp.ONE)) {\n      // (4. If t = 0, return r = 0)\n      // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO;\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift,\n      // otherwise there will be overflow.\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    return function sqrt3mod4(Fp, n) {\n      const p1div4 = (P + _1n) / _4n;\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    return function sqrt5mod8(Fp, n) {\n      const n2 = Fp.mul(n, _2n);\n      const c1 = (P - _5n) / _8n;\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];\nexport function validateField(field) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger'\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  // @ts-ignore\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p)..\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n  const legc = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, legc);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('Cannot find square root: probably non-prime P');\n  return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n  const l = FpLegendre(Fp, n);\n  return l === 0 || l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return {\n    nBitLength: _nBitLength,\n    nByteLength\n  };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const {\n    nBitLength: BITS,\n    nByteLength: BYTES\n  } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP; // cached sqrtP\n  const f = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: num => mod(num, ORDER),\n    isValid: num => {\n      if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: num => num === _0n,\n    isOdd: num => (num & _1n) === _1n,\n    neg: num => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n    sqr: num => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n    // Same as above, but doesn't normalize\n    sqrN: num => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n    inv: num => invert(num, ORDER),\n    sqrt: redef.sqrt || (n => {\n      if (!sqrtP) sqrtP = FpSqrt(ORDER);\n      return sqrtP(f, n);\n    }),\n    toBytes: num => isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),\n    fromBytes: bytes => {\n      if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: lst => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => c ? b : a\n  });\n  return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}","map":{"version":3,"names":["anumber","bitMask","bytesToNumberBE","bytesToNumberLE","ensureBytes","numberToBytesBE","numberToBytesLE","validateObject","_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_8n","_9n","_16n","mod","a","b","result","pow","num","power","modulo","Error","res","pow2","x","invert","number","y","u","v","q","r","m","n","gcd","tonelliShanks","P","Q","S","Z","_Fp","Field","FpIsSquare","p1div4","tonelliFast","Fp","root","eql","sqr","Q1div2","tonelliSlow","g","mul","ONE","ZERO","t2","ge","FpSqrt","sqrt3mod4","sqrt5mod8","n2","c1","nv","i","sub","isNegativeLE","FIELD_FIELDS","validateField","field","initial","ORDER","MASK","BYTES","BITS","opts","reduce","map","val","FpPow","p","d","FpInvertBatch","nums","passZero","inverted","Array","length","fill","undefined","multipliedAcc","acc","is0","invertedAcc","inv","reduceRight","FpDiv","lhs","rhs","FpLegendre","legc","powered","yes","zero","no","neg","l","nLength","nBitLength","_nBitLength","toString","nByteLength","Math","ceil","bitLen","isLE","redef","sqrtP","f","Object","freeze","create","isValid","isOdd","add","div","sqrN","addN","subN","mulN","sqrt","toBytes","fromBytes","bytes","invertBatch","lst","cmov","c","FpSqrtOdd","elm","FpSqrtEven","hashToPrivateScalar","hash","groupOrder","hashLen","minLen","getFieldBytesLength","fieldOrder","bitLength","getMinHashLength","mapHashToField","key","len","fieldLen","reduced"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/modular.js"],"sourcesContent":["/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { anumber } from '@noble/hashes/utils';\nimport { bitMask, bytesToNumberBE, bytesToNumberLE, ensureBytes, numberToBytesBE, numberToBytesLE, validateObject, } from \"./utils.js\";\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nexport function mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * TODO: remove.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P) {\n    // Do expensive precomputation step\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p-1 == q*(2^s) with q odd\n    let Q = P - _1n;\n    let S = 0;\n    while (Q % _2n === _0n) {\n        Q /= _2n;\n        S++;\n    }\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (Z < P && FpIsSquare(_Fp, Z)) {\n        if (Z++ > 1000)\n            throw new Error('Cannot find square root: probably non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (!FpIsSquare(Fp, n))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: test on Fp2 and others\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            // (4. If t = 0, return r = 0)\n            // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO;\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift,\n            // otherwise there will be overflow.\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P) {\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        return function sqrt3mod4(Fp, n) {\n            const p1div4 = (P + _1n) / _4n;\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const c1 = (P - _5n) / _8n;\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nexport function validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return validateObject(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow(Fp, num, power) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return Fp.ONE;\n    if (power === _1n)\n        return num;\n    // @ts-ignore\n    let p = Fp.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (Fp.is0(num))\n            return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nexport function FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p)..\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(Fp, n) {\n    const legc = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, legc);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no)\n        throw new Error('Cannot find square root: probably non-prime P');\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 0 || l === 1;\n}\n// CURVE.n lengths\nexport function nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined)\n        anumber(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: bitMask(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c) => (c ? b : a),\n    });\n    return Object.freeze(f);\n}\nexport function FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nexport function FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = ensureBytes('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}