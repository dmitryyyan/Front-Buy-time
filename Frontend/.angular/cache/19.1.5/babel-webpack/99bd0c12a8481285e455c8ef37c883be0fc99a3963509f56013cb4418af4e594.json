{"ast":null,"code":"import { FpInvertBatch, mod } from \"./modular.js\";\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from \"./utils.js\";\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << 8 * length) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({\n    length\n  }).fill(0);\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\nfunction anum(item) {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const {\n    outputLen: b_in_bytes,\n    blockLen: r_in_bytes\n  } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil(2 * k / 8);\n    DST = H.create({\n      dkLen\n    }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255) throw new Error('expand_message_xof: invalid lenInBytes');\n  return H.create({\n    dkLen: lenInBytes\n  }).update(msg).update(i2osp(lenInBytes, 2))\n  // 2. DST_prime = DST || I2OSP(len(DST), 1)\n  .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash'\n  });\n  const {\n    p,\n    k,\n    m,\n    hash,\n    expand,\n    DST: _DST\n  } = options;\n  abytes(msg);\n  anum(count);\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\nexport function isogenyMap(field, map) {\n  // Make same order as in spec\n  const coeff = map.map(i => Array.from(i).reverse());\n  return (x, y) => {\n    const [xn, xd, yn, yd] = coeff.map(val => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return {\n      x,\n      y\n    };\n  };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nexport function createHasher(Point, mapToCurve, defaults) {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n  return {\n    defaults,\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg, options) {\n      const u = hash_to_field(msg, 2, {\n        ...defaults,\n        DST: defaults.DST,\n        ...options\n      });\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg, options) {\n      const u = hash_to_field(msg, 1, {\n        ...defaults,\n        DST: defaults.encodeDST,\n        ...options\n      });\n      return clear(map(u[0]));\n    },\n    // Same as encodeToCurve, but without hash\n    mapToCurve(scalars) {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars) if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    }\n  };\n}","map":{"version":3,"names":["FpInvertBatch","mod","abytes","bytesToNumberBE","concatBytes","utf8ToBytes","validateObject","os2ip","i2osp","value","length","anum","Error","res","Array","from","fill","i","Uint8Array","strxor","a","b","arr","item","Number","isSafeInteger","expand_message_xmd","msg","DST","lenInBytes","H","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","Math","ceil","DST_prime","Z_pad","l_i_b_str","b_0","args","pseudo_random_bytes","slice","expand_message_xof","k","dkLen","create","update","digest","hash_to_field","count","options","p","m","hash","expand","_DST","log2p","toString","L","len_in_bytes","prb","u","e","j","elm_offset","tv","subarray","isogenyMap","field","map","coeff","reverse","x","y","xn","xd","yn","yd","val","reduce","acc","add","mul","xd_inv","yd_inv","createHasher","Point","mapToCurve","defaults","num","fromAffine","clear","initial","P","clearCofactor","equals","ZERO","assertValidity","hashToCurve","u0","u1","encodeToCurve","encodeDST","scalars","isArray"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/hash-to-curve.js"],"sourcesContent":["import { FpInvertBatch, mod } from \"./modular.js\";\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from \"./utils.js\";\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(msg, DST, lenInBytes, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H(concatBytes(...args));\n    }\n    const pseudo_random_bytes = concatBytes(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    abytes(msg);\n    abytes(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg, count, options) {\n    validateObject(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    abytes(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = mod(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nexport function isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xn, xd, yn, yd] = coeff.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nexport function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO))\n            return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...defaults, DST: defaults.DST, ...options });\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...defaults, DST: defaults.encodeDST, ...options });\n            return clear(map(u[0]));\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('expected array of bigints');\n            return clear(map(scalars));\n        },\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}