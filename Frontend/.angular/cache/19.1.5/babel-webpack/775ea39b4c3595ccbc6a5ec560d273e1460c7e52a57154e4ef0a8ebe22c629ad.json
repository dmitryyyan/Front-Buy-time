{"ast":null,"code":"/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = require(\"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */\nfunction checkUint8Array(b) {\n  if (!(b instanceof Uint8Array)) {\n    throw new TypeError('b must be a Uint8Array');\n  }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */\nfunction uint8ArrayToBuffer(b) {\n  checkUint8Array(b);\n  return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Uint8Array} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\n// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n  if ('function' !== typeof Class) {\n    throw new TypeError('Class must be constructor');\n  }\n  if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n    throw new Error('Class is already bound to a layout');\n  }\n  if (!(layout && layout instanceof Layout)) {\n    throw new TypeError('layout must be a Layout');\n  }\n  if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n    throw new Error('layout is already bound to a constructor');\n  }\n  Class.layout_ = layout;\n  layout.boundConstructor_ = Class;\n  layout.makeDestinationObject = () => new Class();\n  Object.defineProperty(Class.prototype, 'encode', {\n    value(b, offset) {\n      return layout.encode(this, b, offset);\n    },\n    writable: true\n  });\n  Object.defineProperty(Class, 'decode', {\n    value(b, offset) {\n      return layout.decode(b, offset);\n    },\n    writable: true\n  });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n  constructor(elementSpan = 1, property) {\n    if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n      throw new TypeError('elementSpan must be a (positive) integer');\n    }\n    super(-1, property);\n    /** The layout for individual elements of the sequence.  The value\n     * must be a positive integer.  If not provided, the value will be\n     * 1. */\n    this.elementSpan = elementSpan;\n  }\n  /** @override */\n  isCount() {\n    return true;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    checkUint8Array(b);\n    const rem = b.length - offset;\n    return Math.floor(rem / this.elementSpan);\n  }\n  /** @override */\n  encode(src, b, offset) {\n    return 0;\n  }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset = 0, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n    if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n    super(layout.span, property || layout.property);\n    /** The subordinated layout. */\n    this.layout = layout;\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Uint8Array\n     * being accessed.  */\n    this.offset = offset;\n  }\n  /** @override */\n  isCount() {\n    return this.layout instanceof UInt || this.layout instanceof UIntBE;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return this.layout.decode(b, offset + this.offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - hi32 * V2E32;\n  return {\n    hi32,\n    lo32\n  };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const lo32 = buffer.readUInt32LE(offset);\n    const hi32 = buffer.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const hi32 = buffer.readUInt32BE(offset);\n    const lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const lo32 = buffer.readUInt32LE(offset);\n    const hi32 = buffer.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeUInt32LE(split.lo32, offset);\n    buffer.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const buffer = uint8ArrayToBuffer(b);\n    const hi32 = buffer.readInt32BE(offset);\n    const lo32 = buffer.readUInt32BE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    const split = divmodInt64(src);\n    const buffer = uint8ArrayToBuffer(b);\n    buffer.writeInt32BE(split.hi32, offset);\n    buffer.writeUInt32BE(split.lo32, offset + 4);\n    return 8;\n  }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readFloatLE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n    return 4;\n  }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n  constructor(property) {\n    super(4, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readFloatBE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n    return 4;\n  }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readDoubleLE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n    return 8;\n  }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    return uint8ArrayToBuffer(b).readDoubleBE(offset);\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n    return 8;\n  }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n  constructor(elementLayout, count, property) {\n    if (!(elementLayout instanceof Layout)) {\n      throw new TypeError('elementLayout must be a Layout');\n    }\n    if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n      throw new TypeError('count must be non-negative integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n      span = count * elementLayout.span;\n    }\n    super(span, property);\n    /** The layout for individual elements of the sequence. */\n    this.elementLayout = elementLayout;\n    /** The number of elements in the sequence.\n     *\n     * This will be either a non-negative integer or an instance of\n     * {@link ExternalLayout} for which {@link\n     * ExternalLayout#isCount|isCount()} is `true`. */\n    this.count = count;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    let span = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    if (0 < this.elementLayout.span) {\n      span = count * this.elementLayout.span;\n    } else {\n      let idx = 0;\n      while (idx < count) {\n        span += this.elementLayout.getSpan(b, offset + span);\n        ++idx;\n      }\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const rv = [];\n    let i = 0;\n    let count = this.count;\n    if (count instanceof ExternalLayout) {\n      count = count.decode(b, offset);\n    }\n    while (i < count) {\n      rv.push(this.elementLayout.decode(b, offset));\n      offset += this.elementLayout.getSpan(b, offset);\n      i += 1;\n    }\n    return rv;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n   *\n   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n   * the unused space in the buffer is left unchanged.  If `src` is\n   * longer than {@link Sequence#count|count} the unneeded elements are\n   * ignored.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset = 0) {\n    const elo = this.elementLayout;\n    const span = src.reduce((span, v) => {\n      return span + elo.encode(v, b, offset + span);\n    }, 0);\n    if (this.count instanceof ExternalLayout) {\n      this.count.encode(src.length, b, offset);\n    }\n    return span;\n  }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if ('boolean' === typeof property && undefined === decodePrefixes) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if (0 > fd.span && undefined === fd.property) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n      // ignore error\n    }\n    super(span, property);\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    checkUint8Array(b);\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes && b.length === offset) {\n        break;\n      }\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset = 0) {\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = 0 < span ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return lastOffset + lastWrote - firstOffset;\n  }\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property && 0 < values.length) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n    return undefined;\n  }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode(b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode(src, b, offset) {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!(layout instanceof ExternalLayout && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n    super(property || layout.property || 'variant');\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    let discriminator;\n    if (discr instanceof UInt || discr instanceof UIntBE) {\n      discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if (discr instanceof ExternalLayout && discr.isCount()) {\n      discriminator = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator ' + 'or an unsigned integer layout');\n    } else {\n      discriminator = discr;\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n        span += discriminator.layout.span;\n      }\n    }\n    super(span, property);\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discriminator;\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function (src) {\n      return boundGetSourceVariant(src);\n    };\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function (gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisfied rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset = 0) {\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    const clo = this.registry[discr];\n    if (undefined === clo) {\n      const defaultLayout = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset = 0) {\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      // this.defaultLayout is not undefined when vlo is undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      // clo.property is not undefined when vlo is undefined\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Uint8Array)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Uint8Array}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset = 0) {\n    let variant;\n    if (vb instanceof Uint8Array) {\n      variant = this.discriminator.decode(vb, offset);\n    } else {\n      variant = vb;\n    }\n    return this.registry[variant];\n  }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if (!Number.isInteger(variant) || 0 > variant) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if ('string' === typeof layout && undefined === property) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if (null !== union.defaultLayout && 0 <= layout.span && layout.span > union.defaultLayout.span) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if (0 <= span && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    let span = 0;\n    if (this.layout) {\n      span = this.layout.getSpan(b, offset + contentOffset);\n    }\n    return contentOffset + span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const dest = this.makeDestinationObject();\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if (0 <= this.union.span && span > this.union.span) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n    return undefined;\n  }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n  if (0 > v) {\n    v += 0x100000000;\n  }\n  return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n  constructor(word, msb, property) {\n    if (!(word instanceof UInt || word instanceof UIntBE)) {\n      throw new TypeError('word must be a UInt or UIntBE layout');\n    }\n    if ('string' === typeof msb && undefined === property) {\n      property = msb;\n      msb = false;\n    }\n    if (4 < word.span) {\n      throw new RangeError('word cannot exceed 32 bits');\n    }\n    super(word.span, property);\n    /** The layout used for the packed value.  {@link BitField}\n     * instances are packed sequentially depending on {@link\n     * BitStructure#msb|msb}. */\n    this.word = word;\n    /** Whether the bit sequences are packed starting at the most\n     * significant bit growing down (`true`), or the least significant\n     * bit growing up (`false`).\n     *\n     * **NOTE** Regardless of this value, the least significant bit of\n     * any {@link BitField} value is the least significant bit of the\n     * corresponding section of the packed value. */\n    this.msb = !!msb;\n    /** The sequence of {@link BitField} layouts that comprise the\n     * packed structure.\n     *\n     * **NOTE** The array remains mutable to allow fields to be {@link\n     * BitStructure#addField|added} after construction.  Users should\n     * not manipulate the content of this property.*/\n    this.fields = [];\n    /* Storage for the value.  Capture a variable instead of using an\n     * instance property because we don't want anything to change the\n     * value without going through the mutator. */\n    let value = 0;\n    this._packedSetValue = function (v) {\n      value = fixBitwiseResult(v);\n      return this;\n    };\n    this._packedGetValue = function () {\n      return value;\n    };\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const dest = this.makeDestinationObject();\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b);\n      }\n    }\n    return dest;\n  }\n  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the packed\n   * value is left unmodified.  Unused bits are also left unmodified. */\n  encode(src, b, offset = 0) {\n    const value = this.word.decode(b, offset);\n    this._packedSetValue(value);\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          fd.encode(fv);\n        }\n      }\n    }\n    return this.word.encode(this._packedGetValue(), b, offset);\n  }\n  /** Register a new bitfield with a containing bit structure.  The\n   * resulting bitfield is returned.\n   *\n   * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {BitField} */\n  addField(bits, property) {\n    const bf = new BitField(this, bits, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /** As with {@link BitStructure#addField|addField} for single-bit\n   * fields with `boolean` value representation.\n   *\n   * @param {string} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {Boolean} */\n  // `Boolean` conflicts with the native primitive type\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  addBoolean(property) {\n    // This is my Boolean, not the Javascript one.\n    const bf = new Boolean(this, property);\n    this.fields.push(bf);\n    return bf;\n  }\n  /**\n   * Get access to the bit field for a given property.\n   *\n   * @param {String} property - the bit field of interest.\n   *\n   * @return {BitField} - the field associated with `property`, or\n   * undefined if there is no such property.\n   */\n  fieldFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n    return undefined;\n  }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n  constructor(container, bits, property) {\n    if (!(container instanceof BitStructure)) {\n      throw new TypeError('container must be a BitStructure');\n    }\n    if (!Number.isInteger(bits) || 0 >= bits) {\n      throw new TypeError('bits must be positive integer');\n    }\n    const totalBits = 8 * container.span;\n    const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n    if (bits + usedBits > totalBits) {\n      throw new Error('bits too long for span remainder (' + (totalBits - usedBits) + ' of ' + totalBits + ' remain)');\n    }\n    /** The {@link BitStructure} instance to which this bit field\n     * belongs. */\n    this.container = container;\n    /** The span of this value in bits. */\n    this.bits = bits;\n    /** A mask of {@link BitField#bits|bits} bits isolating value bits\n     * that fit within the field.\n     *\n     * That is, it masks a value that has not yet been shifted into\n     * position within its containing packed integer. */\n    this.valueMask = (1 << bits) - 1;\n    if (32 === bits) {\n      // shifted value out of range\n      this.valueMask = 0xFFFFFFFF;\n    }\n    /** The offset of the value within the containing packed unsigned\n     * integer.  The least significant bit of the packed value is at\n     * offset zero, regardless of bit ordering used. */\n    this.start = usedBits;\n    if (this.container.msb) {\n      this.start = totalBits - usedBits - bits;\n    }\n    /** A mask of {@link BitField#bits|bits} isolating the field value\n     * within the containing packed unsigned integer. */\n    this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n    /** The property name used when this bitfield is represented in an\n     * Object.\n     *\n     * Intended to be functionally equivalent to {@link\n     * Layout#property}.\n     *\n     * If left undefined the corresponding span of bits will be\n     * treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field. */\n  decode(b, offset) {\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(word & this.wordMask);\n    const value = wordValue >>> this.start;\n    return value;\n  }\n  /** Store a value into the corresponding subsequence of the containing\n   * bit field.\n   *\n   * **NOTE** This is not a specialization of {@link\n   * Layout#encode|Layout.encode} and there is no return value. */\n  encode(value) {\n    if ('number' !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n      throw new TypeError(nameWithProperty('BitField.encode', this) + ' value must be integer not exceeding ' + this.valueMask);\n    }\n    const word = this.container._packedGetValue();\n    const wordValue = fixBitwiseResult(value << this.start);\n    this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n  }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n  constructor(container, property) {\n    super(container, 1, property);\n  }\n  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n   *\n   * @returns {boolean} */\n  decode(b, offset) {\n    return !!super.decode(b, offset);\n  }\n  /** @override */\n  encode(value) {\n    if ('boolean' === typeof value) {\n      // BitField requires integer values\n      value = +value;\n    }\n    super.encode(value);\n  }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n  constructor(length, property) {\n    if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n      throw new TypeError('length must be positive integer ' + 'or an unsigned integer ExternalLayout');\n    }\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return uint8ArrayToBuffer(b).slice(offset, offset + span);\n  }\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(src instanceof Uint8Array && span === src.length)) {\n      throw new TypeError(nameWithProperty('Blob.encode', this) + ' requires (length ' + span + ') Uint8Array as src');\n    }\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Uint8Array');\n    }\n    const srcBuffer = uint8ArrayToBuffer(src);\n    uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n  constructor(property) {\n    super(-1, property);\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    checkUint8Array(b);\n    let idx = offset;\n    while (idx < b.length && 0 !== b[idx]) {\n      idx += 1;\n    }\n    return 1 + idx - offset;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const span = this.getSpan(b, offset);\n    return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = String(src);\n    }\n    const srcb = buffer_1.Buffer.from(src, 'utf8');\n    const span = srcb.length;\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    const buffer = uint8ArrayToBuffer(b);\n    srcb.copy(buffer, offset);\n    buffer[offset + span] = 0;\n    return span + 1;\n  }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n  constructor(maxSpan, property) {\n    if ('string' === typeof maxSpan && undefined === property) {\n      property = maxSpan;\n      maxSpan = undefined;\n    }\n    if (undefined === maxSpan) {\n      maxSpan = -1;\n    } else if (!Number.isInteger(maxSpan)) {\n      throw new TypeError('maxSpan must be an integer');\n    }\n    super(-1, property);\n    /** The maximum span of the layout in bytes.\n     *\n     * Positive values are generally expected.  Zero is abnormal.\n     * Attempts to encode or decode a value that exceeds this length\n     * will throw a `RangeError`.\n     *\n     * A negative value indicates that there is no bound on the length\n     * of the content. */\n    this.maxSpan = maxSpan;\n  }\n  /** @override */\n  getSpan(b, offset = 0) {\n    checkUint8Array(b);\n    return b.length - offset;\n  }\n  /** @override */\n  decode(b, offset = 0) {\n    const span = this.getSpan(b, offset);\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n  }\n  /** @override */\n  encode(src, b, offset = 0) {\n    /* Must force this to a string, lest it be a number and the\n     * \"utf8-encoding\" below actually allocate a buffer of length\n     * src */\n    if ('string' !== typeof src) {\n      src = String(src);\n    }\n    const srcb = buffer_1.Buffer.from(src, 'utf8');\n    const span = srcb.length;\n    if (0 <= this.maxSpan && this.maxSpan < span) {\n      throw new RangeError('text length exceeds maxSpan');\n    }\n    if (offset + span > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    srcb.copy(uint8ArrayToBuffer(b), offset);\n    return span;\n  }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n  constructor(value, property) {\n    super(0, property);\n    /** The value produced by this constant when the layout is {@link\n     * Constant#decode|decoded}.\n     *\n     * Any JavaScript value including `null` and `undefined` is\n     * permitted.\n     *\n     * **WARNING** If `value` passed in the constructor was not\n     * frozen, it is possible for users of decoded values to change\n     * the content of the value. */\n    this.value = value;\n  }\n  /** @override */\n  decode(b, offset) {\n    return this.value;\n  }\n  /** @override */\n  encode(src, b, offset) {\n    /* Constants take no space */\n    return 0;\n  }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\nexports.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);\n/** Factory for {@link OffsetLayout}. */\nexports.offset = (layout, offset, property) => new OffsetLayout(layout, offset, property);\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = property => new UInt(1, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = property => new UInt(2, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = property => new UInt(3, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = property => new UInt(4, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = property => new UInt(5, property);\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = property => new UInt(6, property);\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = property => new NearUInt64(property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = property => new UIntBE(2, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = property => new UIntBE(3, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = property => new UIntBE(4, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = property => new UIntBE(5, property);\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = property => new UIntBE(6, property);\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = property => new NearUInt64BE(property);\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = property => new Int(1, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = property => new Int(2, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = property => new Int(3, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = property => new Int(4, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = property => new Int(5, property);\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = property => new Int(6, property);\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = property => new NearInt64(property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = property => new IntBE(2, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = property => new IntBE(3, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = property => new IntBE(4, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = property => new IntBE(5, property);\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = property => new IntBE(6, property);\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = property => new NearInt64BE(property);\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = property => new Float(property);\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = property => new FloatBE(property);\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = property => new Double(property);\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = property => new DoubleBE(property);\n/** Factory for {@link Structure} values. */\nexports.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);\n/** Factory for {@link BitStructure} values. */\nexports.bits = (word, msb, property) => new BitStructure(word, msb, property);\n/** Factory for {@link Sequence} values. */\nexports.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);\n/** Factory for {@link Union} values. */\nexports.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);\n/** Factory for {@link Blob} values. */\nexports.blob = (length, property) => new Blob(length, property);\n/** Factory for {@link CString} values. */\nexports.cstr = property => new CString(property);\n/** Factory for {@link UTF8} values. */\nexports.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);\n/** Factory for {@link Constant} values. */\nexports.constant = (value, property) => new Constant(value, property);","map":{"version":3,"names":["Object","defineProperty","exports","value","s16","s8","nu64be","u48be","u40be","u32be","u24be","u16be","nu64","u48","u40","u32","u24","u16","u8","offset","greedy","Constant","UTF8","CString","Blob","Boolean","BitField","BitStructure","VariantLayout","Union","UnionLayoutDiscriminator","UnionDiscriminator","Structure","Sequence","DoubleBE","Double","FloatBE","Float","NearInt64BE","NearInt64","NearUInt64BE","NearUInt64","IntBE","Int","UIntBE","UInt","OffsetLayout","GreedyCount","ExternalLayout","bindConstructorLayout","nameWithProperty","Layout","uint8ArrayToBuffer","checkUint8Array","constant","utf8","cstr","blob","unionLayoutDiscriminator","union","seq","bits","struct","f64be","f64","f32be","f32","ns64be","s48be","s40be","s32be","s24be","s16be","ns64","s48","s40","s32","s24","buffer_1","require","b","Uint8Array","TypeError","Buffer","from","buffer","byteOffset","length","constructor","span","property","Number","isInteger","makeDestinationObject","getSpan","RangeError","replicate","rv","create","prototype","assign","fromArray","values","undefined","name","lo","Class","layout","hasOwnProperty","call","Error","layout_","boundConstructor_","encode","writable","decode","isCount","elementSpan","rem","Math","floor","src","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","readIntLE","writeIntLE","readIntBE","writeIntBE","V2E32","pow","divmodInt64","hi32","lo32","roundedInt64","readUInt32LE","split","writeUInt32LE","readUInt32BE","writeUInt32BE","readInt32LE","writeInt32LE","readInt32BE","writeInt32BE","readFloatLE","writeFloatLE","readFloatBE","writeFloatBE","readDoubleLE","writeDoubleLE","readDoubleBE","writeDoubleBE","elementLayout","count","idx","i","push","elo","reduce","v","fields","decodePrefixes","Array","isArray","acc","fd","e","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","discr","defaultLayout","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","vb","fixBitwiseResult","word","msb","_packedSetValue","_packedGetValue","addField","bf","addBoolean","fieldFor","container","totalBits","usedBits","sum","valueMask","start","wordMask","wordValue","slice","srcBuffer","write","toString","String","srcb","copy","maxSpan"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@solana/buffer-layout/lib/Layout.js"],"sourcesContent":["/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = require(\"buffer\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */\nfunction checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('b must be a Uint8Array');\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */\nfunction uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n    constructor(span, property) {\n        if (!Number.isInteger(span)) {\n            throw new TypeError('span must be an integer');\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */\n        this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */\n    makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n    getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError('indeterminate span');\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n    replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n    fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + '[' + lo.property + ']';\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\n// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if ('function' !== typeof Class) {\n        throw new TypeError('Class must be constructor');\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n        throw new Error('Class is already bound to a layout');\n    }\n    if (!(layout && (layout instanceof Layout))) {\n        throw new TypeError('layout must be a Layout');\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n        throw new Error('layout is already bound to a constructor');\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = (() => new Class());\n    Object.defineProperty(Class.prototype, 'encode', {\n        value(b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true,\n    });\n    Object.defineProperty(Class, 'decode', {\n        value(b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true,\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    isCount() {\n        throw new Error('ExternalLayout is abstract');\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property) {\n        if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n            throw new TypeError('elementSpan must be a (positive) integer');\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */\n        this.elementSpan = elementSpan;\n    }\n    /** @override */\n    isCount() {\n        return true;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */\n    encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property) {\n        if (!(layout instanceof Layout)) {\n            throw new TypeError('layout must be a Layout');\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError('offset must be integer or undefined');\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */\n        this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */\n        this.offset = offset;\n    }\n    /** @override */\n    isCount() {\n        return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - (hi32 * V2E32);\n    return { hi32, lo32 };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n    constructor(elementLayout, count, property) {\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError('elementLayout must be a Layout');\n        }\n        if (!(((count instanceof ExternalLayout) && count.isCount())\n            || (Number.isInteger(count) && (0 <= count)))) {\n            throw new TypeError('count must be non-negative integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if ((!(count instanceof ExternalLayout))\n            && (0 < elementLayout.span)) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */\n        this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */\n        this.count = count;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        }\n        else {\n            let idx = 0;\n            while (idx < count) {\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while (i < count) {\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v) => {\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n    constructor(fields, property, decodePrefixes) {\n        if (!(Array.isArray(fields)\n            && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n            throw new TypeError('fields must be array of Layout instances');\n        }\n        if (('boolean' === typeof property)\n            && (undefined === decodePrefixes)) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */\n        for (const fd of fields) {\n            if ((0 > fd.span)\n                && (undefined === fd.property)) {\n                throw new Error('fields cannot contain unnamed variable-length layout');\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n        }\n        catch (e) {\n            // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */\n        this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */\n        this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd) => {\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        }\n        catch (e) {\n            throw new RangeError('indeterminate span');\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes\n                && (b.length === offset)) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n    encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields) {\n            let span = fd.span;\n            lastWrote = (0 < span) ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */\n                        span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */\n        return (lastOffset + lastWrote) - firstOffset;\n    }\n    /** @override */\n    fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if ((undefined !== fd.property)\n                && (0 < values.length)) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n    layoutFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n    offsetOf(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        let offset = 0;\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            }\n            else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n    constructor(property) {\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */\n        this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */\n    decode(b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n    encode(src, b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property) {\n        if (!((layout instanceof ExternalLayout)\n            && layout.isCount())) {\n            throw new TypeError('layout must be an unsigned integer ExternalLayout');\n        }\n        super(property || layout.property || 'variant');\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */\n        this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n    constructor(discr, defaultLayout, property) {\n        let discriminator;\n        if ((discr instanceof UInt)\n            || (discr instanceof UIntBE)) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        }\n        else if ((discr instanceof ExternalLayout)\n            && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        }\n        else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError('discr must be a UnionDiscriminator '\n                + 'or an unsigned integer layout');\n        }\n        else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!((null === defaultLayout)\n            || (defaultLayout instanceof Layout))) {\n            throw new TypeError('defaultLayout must be null or a Layout');\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error('defaultLayout must have constant span');\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate('content');\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */\n        let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if ((0 <= span) && ((discr instanceof UInt)\n                || (discr instanceof UIntBE))) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */\n        this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */\n        this.usesPrefixDiscriminator = (discr instanceof UInt)\n            || (discr instanceof UIntBE);\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */\n        this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */\n        this.registry = {};\n        /* Private variable used when invoking getSourceVariant */\n        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */\n        this.getSourceVariant = function (src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n        this.configGetSourceVariant = function (gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */\n        const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error('unable to determine span for unrecognized variant');\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n    defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property\n                && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo\n                && ((!vlo.layout)\n                    || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {\n                return vlo;\n            }\n        }\n        else {\n            for (const tag in this.registry) {\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error('unable to infer src variant');\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n    decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        }\n        else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n    encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n    addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n    getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        }\n        else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n    constructor(union, variant, layout, property) {\n        if (!(union instanceof Union)) {\n            throw new TypeError('union must be a Union');\n        }\n        if ((!Number.isInteger(variant)) || (0 > variant)) {\n            throw new TypeError('variant must be a (non-negative) integer');\n        }\n        if (('string' === typeof layout)\n            && (undefined === property)) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError('layout must be a Layout');\n            }\n            if ((null !== union.defaultLayout)\n                && (0 <= layout.span)\n                && (layout.span > union.defaultLayout.span)) {\n                throw new Error('variant span exceeds span of containing union');\n            }\n            if ('string' !== typeof property) {\n                throw new TypeError('variant must have a String property');\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if ((0 <= span) && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */\n        this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */\n        this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */\n        this.layout = layout || null;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */\n            return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */\n        let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error('variant mismatch');\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        }\n        else if (this.property) {\n            dest[this.property] = true;\n        }\n        else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout\n            && (!Object.prototype.hasOwnProperty.call(src, this.property))) {\n            throw new TypeError('variant lacks property ' + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if ((0 <= this.union.span)\n                && (span > this.union.span)) {\n                throw new Error('encoded variant overruns containing union');\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n    fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n    constructor(word, msb, property) {\n        if (!((word instanceof UInt)\n            || (word instanceof UIntBE))) {\n            throw new TypeError('word must be a UInt or UIntBE layout');\n        }\n        if (('string' === typeof msb)\n            && (undefined === property)) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError('word cannot exceed 32 bits');\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */\n        this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */\n        this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/\n        this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */\n        let value = 0;\n        this._packedSetValue = function (v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function () {\n            return value;\n        };\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n    encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n    addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n    // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n    fieldFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n    constructor(container, bits, property) {\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError('container must be a BitStructure');\n        }\n        if ((!Number.isInteger(bits)) || (0 >= bits)) {\n            throw new TypeError('bits must be positive integer');\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n        if ((bits + usedBits) > totalBits) {\n            throw new Error('bits too long for span remainder ('\n                + (totalBits - usedBits) + ' of '\n                + totalBits + ' remain)');\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */\n        this.container = container;\n        /** The span of this value in bits. */\n        this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */\n        this.valueMask = (1 << bits) - 1;\n        if (32 === bits) { // shifted value out of range\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */\n        this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */\n        this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */\n    decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n    encode(value) {\n        if ('number' !== typeof value\n            || !Number.isInteger(value)\n            || (value !== fixBitwiseResult(value & this.valueMask))) {\n            throw new TypeError(nameWithProperty('BitField.encode', this)\n                + ' value must be integer not exceeding ' + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n            | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n    constructor(container, property) {\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */\n    decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */\n    encode(value) {\n        if ('boolean' === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n    constructor(length, property) {\n        if (!(((length instanceof ExternalLayout) && length.isCount())\n            || (Number.isInteger(length) && (0 <= length)))) {\n            throw new TypeError('length must be positive integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */\n        this.length = length;\n    }\n    /** @override */\n    getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty('Blob.encode', this)\n                + ' requires (length ' + span + ') Uint8Array as src');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Uint8Array');\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n    constructor(property) {\n        super(-1, property);\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while ((idx < b.length) && (0 !== b[idx])) {\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n    constructor(maxSpan, property) {\n        if (('string' === typeof maxSpan) && (undefined === property)) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        }\n        else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError('maxSpan must be an integer');\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */\n        this.maxSpan = maxSpan;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n    constructor(value, property) {\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */\n        this.value = value;\n    }\n    /** @override */\n    decode(b, offset) {\n        return this.value;\n    }\n    /** @override */\n    encode(src, b, offset) {\n        /* Constants take no space */\n        return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = ((property) => new UInt(1, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = ((property) => new UInt(2, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = ((property) => new UInt(3, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = ((property) => new UInt(4, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = ((property) => new UInt(5, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = ((property) => new UInt(6, property));\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = ((property) => new NearUInt64(property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = ((property) => new UIntBE(2, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = ((property) => new UIntBE(3, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = ((property) => new UIntBE(4, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = ((property) => new UIntBE(5, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = ((property) => new UIntBE(6, property));\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = ((property) => new NearUInt64BE(property));\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = ((property) => new Int(1, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = ((property) => new Int(2, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = ((property) => new Int(3, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = ((property) => new Int(4, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = ((property) => new Int(5, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = ((property) => new Int(6, property));\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = ((property) => new NearInt64(property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = ((property) => new IntBE(2, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = ((property) => new IntBE(3, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = ((property) => new IntBE(4, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = ((property) => new IntBE(5, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = ((property) => new IntBE(6, property));\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = ((property) => new NearInt64BE(property));\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = ((property) => new Float(property));\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = ((property) => new FloatBE(property));\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = ((property) => new Double(property));\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = ((property) => new DoubleBE(property));\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n/** Factory for {@link CString} values. */\nexports.cstr = ((property) => new CString(property));\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n/** Factory for {@link Constant} values. */\nexports.constant = ((value, property) => new Constant(value, property));\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,GAAG,GAAGF,OAAO,CAACG,EAAE,GAAGH,OAAO,CAACI,MAAM,GAAGJ,OAAO,CAACK,KAAK,GAAGL,OAAO,CAACM,KAAK,GAAGN,OAAO,CAACO,KAAK,GAAGP,OAAO,CAACQ,KAAK,GAAGR,OAAO,CAACS,KAAK,GAAGT,OAAO,CAACU,IAAI,GAAGV,OAAO,CAACW,GAAG,GAAGX,OAAO,CAACY,GAAG,GAAGZ,OAAO,CAACa,GAAG,GAAGb,OAAO,CAACc,GAAG,GAAGd,OAAO,CAACe,GAAG,GAAGf,OAAO,CAACgB,EAAE,GAAGhB,OAAO,CAACiB,MAAM,GAAGjB,OAAO,CAACkB,MAAM,GAAGlB,OAAO,CAACmB,QAAQ,GAAGnB,OAAO,CAACoB,IAAI,GAAGpB,OAAO,CAACqB,OAAO,GAAGrB,O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AAOA,CAACd,CAAC,EAAE7D,MAAM,EAAE;IACf,IAAI,CAAC,GAAG,IAAI,CAACsE,IAAI,EAAE;MACf,MAAM,IAAIM,UAAU,CAAC,oBAAoB,CAAC;IAC9C;IACA,OAAO,IAAI,CAACN,IAAI;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIO,SAASA,CAACN,QAAQ,EAAE;IAChB,MAAMO,EAAE,GAAGjG,MAAM,CAACkG,MAAM,CAAC,IAAI,CAACV,WAAW,CAACW,SAAS,CAAC;IACpDnG,MAAM,CAACoG,MAAM,CAACH,EAAE,EAAE,IAAI,CAAC;IACvBA,EAAE,CAACP,QAAQ,GAAGA,QAAQ;IACtB,OAAOO,EAAE;EACb;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACII,SAASA,CAACC,MAAM,EAAE;IACd,OAAOC,SAAS;EACpB;AACJ;AACArG,OAAO,CAACiD,MAAM,GAAGA,MAAM;AACvB;AACA;AACA;AACA;AACA;AACA,SAASD,gBAAgBA,CAACsD,IAAI,EAAEC,EAAE,EAAE;EAChC,IAAIA,EAAE,CAACf,QAAQ,EAAE;IACb,OAAOc,IAAI,GAAG,GAAG,GAAGC,EAAE,CAACf,QAAQ,GAAG,GAAG;EACzC;EACA,OAAOc,IAAI;AACf;AACAtG,OAAO,CAACgD,gBAAgB,GAAGA,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,qBAAqBA,CAACyD,KAAK,EAAEC,MAAM,EAAE;EAC1C,IAAI,UAAU,KAAK,OAAOD,KAAK,EAAE;IAC7B,MAAM,IAAIxB,SAAS,CAAC,2BAA2B,CAAC;EACpD;EACA,IAAIlF,MAAM,CAACmG,SAAS,CAACS,cAAc,CAACC,IAAI,CAACH,KAA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CA;AACA;AACA;IACQ,IAAI,CAACyF,aAAa,GAAGA,aAAa;IAClC;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,uBAAuB,GAAIH,KAAK,YAAYpI,IAAI,IAC7CoI,KAAK,YAAYrI,MAAO;IAChC;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACsI,aAAa,GAAGA,aAAa;IAClC;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACG,QAAQ,GAAG,CAAC,CAAC;IAClB;IACA,IAAIC,qBAAqB,GAAG,IAAI,CAACC,uBAAuB,CAACC,IAAI,CAAC,IAAI,CAAC;IACnE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,UAAUhE,GAAG,EAAE;MACnC,OAAO6D,qBAAqB,CAAC7D,GAAG,CAAC;IACrC,CAAC;IACD;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACiE,sBAAsB,GAAG,UAAUC,GAAG,EAAE;MACzCL,qBAAqB,GAAGK,GAAG,CAACH,IAAI,CAAC,IAAI,CAAC;IAC1C,CAAC;EACL;EACA;EACA1F,OAAOA,CAACd,CAAC,EAAE7D,MAAM,GAAG,CAAC,EAAE;IACnB,IAAI,CAAC,IAAI,IAAI,CAACsE,IAAI,EAAE;MAChB,OAAO,IAAI,CAACA,IAAI;IACpB;IACA;AACR;AACA;IACQ,MAAMmG,GAAG,GAAG,IAAI,CAACC,UAAU,CAAC7G,CAAC,EAAE7D,MAAM,CAAC;IACtC,IAAI,CAACyK,GAAG,EAAE;MACN,MAAM,IAAI9E,KAAK,CAAC,mDAAmD,CAAC;IACxE;IACA,OAAO8E,GAAG,CAAC9F,OAAO,CAACd,CAAC,EAAE7D,MAAM,CAAC;EACjC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}