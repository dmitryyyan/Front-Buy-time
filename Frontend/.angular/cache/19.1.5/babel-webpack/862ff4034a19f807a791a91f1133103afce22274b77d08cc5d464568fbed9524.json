{"ast":null,"code":"/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from \"./modular.js\";\nimport { bitLen, bitMask, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return {\n    windows,\n    windowSize,\n    mask,\n    maxNumber,\n    shiftBy\n  };\n}\nfunction calcOffsets(n, window, wOpts) {\n  const {\n    windowSize,\n    mask,\n    maxNumber,\n    shiftBy\n  } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return {\n    nextN,\n    offset,\n    isZero,\n    isNeg,\n    isNegF,\n    offsetF\n  };\n}\nfunction validateMSMPoints(points, c) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars, field) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n  return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n  return {\n    constTimeNegate,\n    hasPrecomputes(elm) {\n      return getW(elm) !== 1;\n    },\n    // non-const time multiplication ladder\n    unsafeLadder(elm, n, p = c.ZERO) {\n      let d = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n     * - ùëä is the window size\n     * - ùëõ is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm, W) {\n      const {\n        windows,\n        windowSize\n      } = calcWOpts(W, bits);\n      const points = [];\n      let p = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // i=1, bc we skip 0\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n      // Smaller version:\n      // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n      // TODO: check the scalar is less than group order?\n      // wNAF behavior is undefined otherwise. But have to carefully remove\n      // other checks before wNAF. ORDER == bits here.\n      // Accumulators\n      let p = c.ZERO;\n      let f = c.BASE;\n      // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n      // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n      // there is negate now: it is possible that negated element from low value\n      // would be the same as high element, which will create carry into next window.\n      // It's not obvious how this can fail, but still worth investigating later.\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n        const {\n          nextN,\n          offset,\n          isZero,\n          isNeg,\n          isNegF,\n          offsetF\n        } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // bits are 0: add garbage to fake point\n          // Important part for const-time getPublicKey: add random \"noise\" point to f.\n          f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n        } else {\n          // bits are 1: add to result point\n          p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n        }\n      }\n      // Return both real and fake points: JIT won't eliminate f.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return {\n        p,\n        f\n      };\n    },\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n      const wo = calcWOpts(W, bits);\n      for (let window = 0; window < wo.windows; window++) {\n        if (n === _0n) break; // Early-exit, skip 0 value\n        const {\n          nextN,\n          offset,\n          isZero,\n          isNeg\n        } = calcOffsets(n, window, wo);\n        n = nextN;\n        if (isZero) {\n          // Window bits are 0: skip processing.\n          // Move to next window.\n          continue;\n        } else {\n          const item = precomputes[offset];\n          acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n        }\n      }\n      return acc;\n    },\n    getPrecomputes(W, P, transform) {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W);\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n    wNAFCached(P, n, transform) {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n    wNAFCachedUnsafe(P, n, transform, prev) {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    setWindowSize(P, W) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    }\n  };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length) throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number(scalar >> BigInt(i) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255 √ó 32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map(p => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return scalars => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length) throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number(n >> shiftBy & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\nexport function validateBasic(curve) {\n  validateField(curve.Fp);\n  validateObject(curve, {\n    n: 'bigint',\n    h: 'bigint',\n    Gx: 'field',\n    Gy: 'field'\n  }, {\n    nBitLength: 'isSafeInteger',\n    nByteLength: 'isSafeInteger'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{\n      p: curve.Fp.ORDER\n    }\n  });\n}","map":{"version":3,"names":["nLength","validateField","bitLen","bitMask","validateObject","_0n","BigInt","_1n","constTimeNegate","condition","item","neg","negate","validateW","W","bits","Number","isSafeInteger","Error","calcWOpts","scalarBits","windows","Math","ceil","windowSize","maxNumber","mask","shiftBy","calcOffsets","n","window","wOpts","wbits","nextN","offsetStart","offset","abs","isZero","isNeg","isNegF","offsetF","validateMSMPoints","points","c","Array","isArray","forEach","p","i","validateMSMScalars","scalars","field","s","isValid","pointPrecomputes","WeakMap","pointWindowSizes","getW","P","get","wNAF","hasPrecomputes","elm","unsafeLadder","ZERO","d","add","double","precomputeWindow","base","push","precomputes","f","BASE","wo","wNAFUnsafe","acc","getPrecomputes","transform","comp","set","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","delete","pippenger","fieldN","length","zero","MASK","buckets","fill","lastBits","floor","BITS","sum","j","scalar","resI","sumI","precomputeMSMUnsafe","tableSize","chunks","tables","map","res","curr","validateBasic","curve","Fp","h","Gx","Gy","nBitLength","nByteLength","Object","freeze","ORDER"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/curve.js"],"sourcesContent":["/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { nLength, validateField } from \"./modular.js\";\nimport { bitLen, bitMask, validateObject } from \"./utils.js\";\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = bitMask(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return { windows, windowSize, mask, maxNumber, shiftBy };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ùëä) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(ùëä‚àí1) * (Math.ceil(ùëõ / ùëä) + 1), where:\n         * - ùëä is the window size\n         * - ùëõ is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // i=1, bc we skip 0\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // Smaller version:\n            // https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n            // TODO: check the scalar is less than group order?\n            // wNAF behavior is undefined otherwise. But have to carefully remove\n            // other checks before wNAF. ORDER == bits here.\n            // Accumulators\n            let p = c.ZERO;\n            let f = c.BASE;\n            // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n            // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n            // there is negate now: it is possible that negated element from low value\n            // would be the same as high element, which will create carry into next window.\n            // It's not obvious how this can fail, but still worth investigating later.\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n                const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // bits are 0: add garbage to fake point\n                    // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                    f = f.add(constTimeNegate(isNegF, precomputes[offsetF]));\n                }\n                else {\n                    // bits are 1: add to result point\n                    p = p.add(constTimeNegate(isNeg, precomputes[offset]));\n                }\n            }\n            // Return both real and fake points: JIT won't eliminate f.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const wo = calcWOpts(W, bits);\n            for (let window = 0; window < wo.windows; window++) {\n                if (n === _0n)\n                    break; // Early-exit, skip 0 value\n                const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n                n = nextN;\n                if (isZero) {\n                    // Window bits are 0: skip processing.\n                    // Move to next window.\n                    continue;\n                }\n                else {\n                    const item = precomputes[offset];\n                    acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n                }\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar √ó 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 √ó 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 √ó 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = bitMask(windowSize);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nexport function validateBasic(curve) {\n    validateField(curve.Fp);\n    validateObject(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...nLength(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}