{"ast":null,"code":"/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\nimport { Field, FpInvertBatch, mod } from \"./modular.js\";\n// prettier-ignore\nimport { abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes, ensureBytes, memoized, numberToBytesLE, validateObject } from \"./utils.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = BigInt(2),\n  _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = {\n  zip215: true\n};\nfunction validateOpts(curve) {\n  const opts = validateBasic(curve);\n  validateObject(curve, {\n    hash: 'function',\n    a: 'bigint',\n    d: 'bigint',\n    randomBytes: 'function'\n  }, {\n    adjustScalarBytes: 'function',\n    domain: 'function',\n    uvRatio: 'function',\n    mapToCurve: 'function'\n  });\n  // Set defaults\n  return Object.freeze({\n    ...opts\n  });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n  const CURVE = validateOpts(curveDef);\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << BigInt(nByteLength * 8) - _1n;\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n  // sqrt(u/v)\n  const uvRatio = CURVE.uvRatio || ((u, v) => {\n    try {\n      return {\n        isValid: true,\n        value: Fp.sqrt(u * Fp.inv(v))\n      };\n    } catch (e) {\n      return {\n        isValid: false,\n        value: _0n\n      };\n    }\n  });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || (bytes => bytes); // NOOP\n  const domain = CURVE.domain || ((data, ctx, phflag) => {\n    abool('phflag', phflag);\n    if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n    return data;\n  }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title, n, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n  }\n  function aextpoint(other) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p, iz) => {\n    const {\n      ex: x,\n      ey: y,\n      ez: z\n    } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return {\n      x: _0n,\n      y: _1n\n    };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return {\n      x: ax,\n      y: ay\n    };\n  });\n  const assertValidMemo = memoized(p => {\n    const {\n      a,\n      d\n    } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n    const {\n      ex: X,\n      ey: Y,\n      ez: Z,\n      et: T\n    } = p;\n    const X2 = modP(X * X); // X²\n    const Y2 = modP(Y * Y); // Y²\n    const Z2 = modP(Z * Z); // Z²\n    const Z4 = modP(Z2 * Z2); // Z⁴\n    const aX2 = modP(X2 * a); // aX²\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n  // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point {\n    constructor(ex, ey, ez, et) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez, true);\n      aCoordinate('t', et);\n      this.ex = ex;\n      this.ey = ey;\n      this.ez = ez;\n      this.et = et;\n      Object.freeze(this);\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    static fromAffine(p) {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const {\n        x,\n        y\n      } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points) {\n      const toInv = FpInvertBatch(Fp, points.map(p => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points, scalars) {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity() {\n      assertValidMemo(this);\n    }\n    // Compare one point to another.\n    equals(other) {\n      aextpoint(other);\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2\n      } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    negate() {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double() {\n      const {\n        a\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1\n      } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other) {\n      aextpoint(other);\n      const {\n        a,\n        d\n      } = CURVE;\n      const {\n        ex: X1,\n        ey: Y1,\n        ez: Z1,\n        et: T1\n      } = this;\n      const {\n        ex: X2,\n        ey: Y2,\n        ez: Z2,\n        et: T2\n      } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n    subtract(other) {\n      return this.add(other.negate());\n    }\n    wNAF(n) {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n    // Constant-time multiplication.\n    multiply(scalar) {\n      const n = scalar;\n      aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const {\n        p,\n        f\n      } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar, acc = Point.ZERO) {\n      const n = scalar;\n      aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder() {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree() {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz) {\n      return toAffineMemo(this, iz);\n    }\n    clearCofactor() {\n      const {\n        h: cofactor\n      } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex, zip215 = false) {\n      const {\n        d,\n        a\n      } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('pointHex.y', y, _0n, max);\n      // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n      // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y² - 1\n      const v = modP(d * y2 - a); // v = d y² + 1.\n      let {\n        isValid,\n        value: x\n      } = uvRatio(u, v); // √(u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({\n        x,\n        y\n      });\n    }\n    static fromPrivateKey(privKey) {\n      const {\n        scalar\n      } = getPrivateScalar(privKey);\n      return G.multiply(scalar); // reduced one call of `toRawBytes`\n    }\n    toRawBytes() {\n      const {\n        x,\n        y\n      } = this.toAffine();\n      const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex() {\n      return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n  Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n  const {\n    BASE: G,\n    ZERO: I\n  } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n  function modN(a) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash) {\n    return modN(bytesToNumberLE(hash));\n  }\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return {\n      head,\n      prefix,\n      scalar\n    };\n  }\n  // Convenience method that creates public key from scalar. RFC8032 5.1.5\n  function getExtendedPublicKey(key) {\n    const {\n      head,\n      prefix,\n      scalar\n    } = getPrivateScalar(key);\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return {\n      head,\n      prefix,\n      scalar,\n      point,\n      pointBytes\n    };\n  }\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey) {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg, privKey, options = {}) {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const {\n      prefix,\n      scalar,\n      pointBytes\n    } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n  const verifyOpts = VERIFY_DEFAULT;\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig, msg, publicKey, options = verifyOpts) {\n    const {\n      context,\n      zip215\n    } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n    const s = bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  const utils = {\n    getExtendedPublicKey,\n    /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n    randomPrivateKey: () => randomBytes(Fp.BYTES),\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point = Point.BASE) {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    }\n  };\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils\n  };\n}","map":{"version":3,"names":["pippenger","validateBasic","wNAF","Field","FpInvertBatch","mod","abool","aInRange","bytesToHex","bytesToNumberLE","concatBytes","ensureBytes","memoized","numberToBytesLE","validateObject","_0n","BigInt","_1n","_2n","_8n","VERIFY_DEFAULT","zip215","validateOpts","curve","opts","hash","a","d","randomBytes","adjustScalarBytes","domain","uvRatio","mapToCurve","Object","freeze","twistedEdwards","curveDef","CURVE","Fp","n","CURVE_ORDER","prehash","cHash","nByteLength","h","cofactor","MASK","modP","create","Fn","nBitLength","u","v","isValid","value","sqrt","inv","e","bytes","data","ctx","phflag","length","Error","aCoordinate","title","banZero","min","aextpoint","other","Point","toAffineMemo","p","iz","ex","x","ey","y","ez","z","is0","ax","ay","zz","assertValidMemo","X","Y","Z","et","T","X2","Y2","Z2","Z4","aX2","left","right","XY","ZT","constructor","toAffine","fromAffine","normalizeZ","points","toInv","map","i","msm","scalars","_setWindowSize","windowSize","wnaf","setWindowSize","assertValidity","equals","X1","Y1","Z1","X1Z2","X2Z1","Y1Z2","Y2Z1","ZERO","negate","double","A","B","C","D","x1y1","E","G","F","H","X3","Y3","T3","Z3","add","T1","T2","subtract","wNAFCached","multiply","scalar","f","multiplyUnsafe","acc","I","wNAFCachedUnsafe","isSmallOrder","isTorsionFree","unsafeLadder","clearCofactor","fromHex","hex","len","BYTES","normed","slice","lastByte","max","ORDER","y2","isXOdd","isLastByteOdd","fromPrivateKey","privKey","getPrivateScalar","toRawBytes","toHex","BASE","Gx","Gy","modN","modN_LE","key","hashed","head","prefix","getExtendedPublicKey","point","pointBytes","getPublicKey","hashDomainToScalar","context","Uint8Array","of","msgs","msg","sign","options","r","R","k","s","res","verifyOpts","verify","sig","publicKey","undefined","SB","error","RkA","utils","randomPrivateKey","precompute","ExtendedPoint"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@noble/curves/esm/abstract/edwards.js"],"sourcesContent":["/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// prettier-ignore\nimport { pippenger, validateBasic, wNAF } from \"./curve.js\";\nimport { Field, FpInvertBatch, mod } from \"./modular.js\";\n// prettier-ignore\nimport { abool, aInRange, bytesToHex, bytesToNumberLE, concatBytes, ensureBytes, memoized, numberToBytesLE, validateObject } from \"./utils.js\";\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = validateBasic(curve);\n    validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    const Fn = Field(CURVE.n, CURVE.nBitLength);\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            abool('phflag', phflag);\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    // 0 <= n < MASK\n    // Coordinates larger than Fp.ORDER are allowed for zip215\n    function aCoordinate(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        aInRange('coordinate ' + title, n, min, MASK);\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = memoized((p, iz) => {\n        const { ex: x, ey: y, ez: z } = p;\n        const is0 = p.is0();\n        if (iz == null)\n            iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n        const ax = modP(x * iz);\n        const ay = modP(y * iz);\n        const zz = modP(z * iz);\n        if (is0)\n            return { x: _0n, y: _1n };\n        if (zz !== _1n)\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    const assertValidMemo = memoized((p) => {\n        const { a, d } = CURVE;\n        if (p.is0())\n            throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { ex: X, ey: Y, ez: Z, et: T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right)\n            throw new Error('bad point: equation left != right (1)');\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT)\n            throw new Error('bad point: equation left != right (2)');\n        return true;\n    });\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            aCoordinate('x', ex);\n            aCoordinate('y', ey);\n            aCoordinate('z', ez, true);\n            aCoordinate('t', et);\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            Object.freeze(this);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            aCoordinate('x', x);\n            aCoordinate('y', y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = FpInvertBatch(Fp, points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return pippenger(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const n = scalar;\n            aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n            const { p, f } = this.wNAF(n);\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            const n = scalar;\n            aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n            if (n === _0n)\n                return I;\n            if (this.is0() || n === _1n)\n                return this;\n            return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n            abool('zip215', zip215);\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = bytesToNumberLE(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            aInRange('pointHex.y', y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            const { scalar } = getPrivateScalar(privKey);\n            return G.multiply(scalar); // reduced one call of `toRawBytes`\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = wNAF(Point, nByteLength * 8);\n    function modN(a) {\n        return mod(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(bytesToNumberLE(hash));\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = Fp.BYTES;\n        key = ensureBytes('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return { head, prefix, scalar };\n    }\n    // Convenience method that creates public key from scalar. RFC8032 5.1.5\n    function getExtendedPublicKey(key) {\n        const { head, prefix, scalar } = getPrivateScalar(key);\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = ensureBytes('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n        const res = concatBytes(R, numberToBytesLE(s, Fp.BYTES));\n        return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = ensureBytes('message', msg);\n        publicKey = ensureBytes('publicKey', publicKey, len);\n        if (zip215 !== undefined)\n            abool('zip215', zip215);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = bytesToNumberLE(sig.slice(len, 2 * len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        /** ed25519 priv keys are uniform 32b. No need to check for modulo bias, like in secp256k1. */\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}