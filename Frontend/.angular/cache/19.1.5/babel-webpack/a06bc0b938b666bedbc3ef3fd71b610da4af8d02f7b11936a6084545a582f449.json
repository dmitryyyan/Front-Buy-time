{"ast":null,"code":"import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = byteArrays => {\n  const nonEmptyByteArrays = byteArrays.filter(arr => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach(arr => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: value => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: encoder.fixedSize + sentinel.length,\n      write\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    ...(encoder.maxSize != null ? {\n      maxSize: encoder.maxSize + sentinel.length\n    } : {}),\n    getSizeFromValue: value => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: decoder.fixedSize + sentinel.length,\n      read\n    });\n  }\n  return createDecoder({\n    ...decoder,\n    ...(decoder.maxSize != null ? {\n      maxSize: decoder.maxSize + sentinel.length\n    } : {}),\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({\n      ...encoder,\n      fixedSize: prefix.fixedSize + encoder.fixedSize,\n      write\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    getSizeFromValue: value => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({\n      ...decoder,\n      fixedSize: prefix.fixedSize + decoder.fixedSize,\n      read\n    });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({\n    ...decoder,\n    ...(maxSize !== null ? {\n      maxSize\n    } : {}),\n    read\n  });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = offset => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({\n        bytes,\n        preOffset,\n        wrapBytes\n      }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({\n        bytes,\n        newPreOffset,\n        postOffset,\n        preOffset,\n        wrapBytes\n      }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({\n      ...encoder,\n      fixedSize\n    });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: value => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({\n      ...decoder,\n      fixedSize\n    });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(resizeEncoder(encoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    preOffset: ({\n      preOffset\n    }) => preOffset + offset\n  });\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(resizeDecoder(decoder, size => size + offset), {\n    postOffset: ({\n      postOffset\n    }) => postOffset + offset\n  });\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...(isVariableSize(encoder) ? {\n      ...encoder,\n      getSizeFromValue: value => encoder.getSizeFromValue(unmap(value))\n    } : encoder),\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["SolanaError","SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH","SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH","SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH","SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH","SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH","SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY","SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH","SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE","SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH","SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES","SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL","mergeBytes","byteArrays","nonEmptyByteArrays","filter","arr","length","Uint8Array","totalLength","reduce","total","result","offset","forEach","set","padBytes","bytes","paddedBytes","fill","fixBytes","slice","containsBytes","data","every","b","i","getEncodedSize","value","encoder","fixedSize","getSizeFromValue","createEncoder","Object","freeze","encode","write","createDecoder","decoder","decode","read","createCodec","codec","isFixedSize","assertIsFixedSize","isVariableSize","assertIsVariableSize","combineCodec","decoderFixedSize","encoderFixedSize","maxSize","decoderMaxSize","encoderMaxSize","addEncoderSentinel","sentinel","encoderBytes","findSentinelIndex","encodedBytes","hexEncodedBytes","hexBytes","hexSentinel","addDecoderSentinel","candidateBytes","sentinelIndex","decodedBytes","hexDecodedBytes","preSentinelBytes","addCodecSentinel","findIndex","byte","index","str","toString","padStart","assertByteArrayIsNotEmptyForCodec","codecDescription","assertByteArrayHasEnoughBytesForCodec","expected","bytesLength","assertByteArrayOffsetIsNotOutOfRange","addEncoderSizePrefix","prefix","prefixMaxSize","encoderSize","addDecoderSizePrefix","bigintSize","decoderOffset","size","Number","addCodecSizePrefix","fixEncoderSize","fixedBytes","variableByteArray","fixedByteArray","fixDecoderSize","fixCodecSize","offsetEncoder","config","preOffset","wrapBytes","modulo","newPreOffset","postOffset","newPostOffset","offsetDecoder","offsetCodec","dividend","divisor","resizeEncoder","resize","newSize","resizeDecoder","resizeCodec","padLeftEncoder","padRightEncoder","padLeftDecoder","padRightDecoder","padLeftCodec","padRightCodec","copySourceToTargetInReverse","source","target_WILL_MUTATE","sourceOffset","sourceLength","targetOffset","leftValue","reverseEncoder","newOffset","reverseDecoder","reversedBytes","reverseCodec","transformEncoder","unmap","transformDecoder","map","transformCodec"],"sources":["C:/Users/user/Desktop/Front/buy-time/Frontend/node_modules/@solana/codecs-core/dist/index.browser.mjs"],"sourcesContent":["import { SolanaError, SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH, SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH, SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL } from '@solana/errors';\n\n// src/add-codec-sentinel.ts\n\n// src/bytes.ts\nvar mergeBytes = (byteArrays) => {\n  const nonEmptyByteArrays = byteArrays.filter((arr) => arr.length);\n  if (nonEmptyByteArrays.length === 0) {\n    return byteArrays.length ? byteArrays[0] : new Uint8Array();\n  }\n  if (nonEmptyByteArrays.length === 1) {\n    return nonEmptyByteArrays[0];\n  }\n  const totalLength = nonEmptyByteArrays.reduce((total, arr) => total + arr.length, 0);\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  nonEmptyByteArrays.forEach((arr) => {\n    result.set(arr, offset);\n    offset += arr.length;\n  });\n  return result;\n};\nvar padBytes = (bytes, length) => {\n  if (bytes.length >= length) return bytes;\n  const paddedBytes = new Uint8Array(length).fill(0);\n  paddedBytes.set(bytes);\n  return paddedBytes;\n};\nvar fixBytes = (bytes, length) => padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n  const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n  if (slice.length !== bytes.length) return false;\n  return bytes.every((b, i) => b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n  return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n  return Object.freeze({\n    ...encoder,\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, encoder));\n      encoder.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction createDecoder(decoder) {\n  return Object.freeze({\n    ...decoder,\n    decode: (bytes, offset = 0) => decoder.read(bytes, offset)[0]\n  });\n}\nfunction createCodec(codec) {\n  return Object.freeze({\n    ...codec,\n    decode: (bytes, offset = 0) => codec.read(bytes, offset)[0],\n    encode: (value) => {\n      const bytes = new Uint8Array(getEncodedSize(value, codec));\n      codec.write(value, bytes, 0);\n      return bytes;\n    }\n  });\n}\nfunction isFixedSize(codec) {\n  return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n  if (!isFixedSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n  }\n}\nfunction isVariableSize(codec) {\n  return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n  if (!isVariableSize(codec)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n  }\n}\nfunction combineCodec(encoder, decoder) {\n  if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n  }\n  if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n      decoderFixedSize: decoder.fixedSize,\n      encoderFixedSize: encoder.fixedSize\n    });\n  }\n  if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n      decoderMaxSize: decoder.maxSize,\n      encoderMaxSize: encoder.maxSize\n    });\n  }\n  return {\n    ...decoder,\n    ...encoder,\n    decode: decoder.decode,\n    encode: encoder.encode,\n    read: decoder.read,\n    write: encoder.write\n  };\n}\n\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n        encodedBytes: encoderBytes,\n        hexEncodedBytes: hexBytes(encoderBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    bytes.set(encoderBytes, offset);\n    offset += encoderBytes.length;\n    bytes.set(sentinel, offset);\n    offset += sentinel.length;\n    return offset;\n  };\n  if (isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: encoder.fixedSize + sentinel.length, write });\n  }\n  return createEncoder({\n    ...encoder,\n    ...encoder.maxSize != null ? { maxSize: encoder.maxSize + sentinel.length } : {},\n    getSizeFromValue: (value) => encoder.getSizeFromValue(value) + sentinel.length,\n    write\n  });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n  const read = (bytes, offset) => {\n    const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n    const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n    if (sentinelIndex === -1) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n        decodedBytes: candidateBytes,\n        hexDecodedBytes: hexBytes(candidateBytes),\n        hexSentinel: hexBytes(sentinel),\n        sentinel\n      });\n    }\n    const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n    return [decoder.decode(preSentinelBytes), offset + preSentinelBytes.length + sentinel.length];\n  };\n  if (isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: decoder.fixedSize + sentinel.length, read });\n  }\n  return createDecoder({\n    ...decoder,\n    ...decoder.maxSize != null ? { maxSize: decoder.maxSize + sentinel.length } : {},\n    read\n  });\n}\nfunction addCodecSentinel(codec, sentinel) {\n  return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n  return bytes.findIndex((byte, index, arr) => {\n    if (sentinel.length === 1) return byte === sentinel[0];\n    return containsBytes(arr, sentinel, index);\n  });\n}\nfunction hexBytes(bytes) {\n  return bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n  if (bytes.length - offset <= 0) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n      codecDescription\n    });\n  }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n  const bytesLength = bytes.length - offset;\n  if (bytesLength < expected) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n      bytesLength,\n      codecDescription,\n      expected\n    });\n  }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n  if (offset < 0 || offset > bytesLength) {\n    throw new SolanaError(SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n      bytesLength,\n      codecDescription,\n      offset\n    });\n  }\n}\n\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n  const write = (value, bytes, offset) => {\n    const encoderBytes = encoder.encode(value);\n    offset = prefix.write(encoderBytes.length, bytes, offset);\n    bytes.set(encoderBytes, offset);\n    return offset + encoderBytes.length;\n  };\n  if (isFixedSize(prefix) && isFixedSize(encoder)) {\n    return createEncoder({ ...encoder, fixedSize: prefix.fixedSize + encoder.fixedSize, write });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n  return createEncoder({\n    ...encoder,\n    ...maxSize !== null ? { maxSize } : {},\n    getSizeFromValue: (value) => {\n      const encoderSize = getEncodedSize(value, encoder);\n      return getEncodedSize(encoderSize, prefix) + encoderSize;\n    },\n    write\n  });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n  const read = (bytes, offset) => {\n    const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n    const size = Number(bigintSize);\n    offset = decoderOffset;\n    if (offset > 0 || bytes.length > size) {\n      bytes = bytes.slice(offset, offset + size);\n    }\n    assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n    return [decoder.decode(bytes), offset + size];\n  };\n  if (isFixedSize(prefix) && isFixedSize(decoder)) {\n    return createDecoder({ ...decoder, fixedSize: prefix.fixedSize + decoder.fixedSize, read });\n  }\n  const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n  const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n  const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n  return createDecoder({ ...decoder, ...maxSize !== null ? { maxSize } : {}, read });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n  return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n  return createEncoder({\n    fixedSize: fixedBytes,\n    write: (value, bytes, offset) => {\n      const variableByteArray = encoder.encode(value);\n      const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n      bytes.set(fixedByteArray, offset);\n      return offset + fixedBytes;\n    }\n  });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n  return createDecoder({\n    fixedSize: fixedBytes,\n    read: (bytes, offset) => {\n      assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n      if (offset > 0 || bytes.length > fixedBytes) {\n        bytes = bytes.slice(offset, offset + fixedBytes);\n      }\n      if (isFixedSize(decoder)) {\n        bytes = fixBytes(bytes, decoder.fixedSize);\n      }\n      const [value] = decoder.read(bytes, 0);\n      return [value, offset + fixedBytes];\n    }\n  });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n  return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n      const postOffset = encoder.write(value, bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n      return newPostOffset;\n    }\n  });\n}\nfunction offsetDecoder(decoder, config) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, preOffset) => {\n      const wrapBytes = (offset) => modulo(offset, bytes.length);\n      const newPreOffset = config.preOffset ? config.preOffset({ bytes, preOffset, wrapBytes }) : preOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n      const [value, postOffset] = decoder.read(bytes, newPreOffset);\n      const newPostOffset = config.postOffset ? config.postOffset({ bytes, newPreOffset, postOffset, preOffset, wrapBytes }) : postOffset;\n      assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n      return [value, newPostOffset];\n    }\n  });\n}\nfunction offsetCodec(codec, config) {\n  return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n  if (divisor === 0) return 0;\n  return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n  if (isFixedSize(encoder)) {\n    const fixedSize = resize(encoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeEncoder\"\n      });\n    }\n    return createEncoder({ ...encoder, fixedSize });\n  }\n  return createEncoder({\n    ...encoder,\n    getSizeFromValue: (value) => {\n      const newSize = resize(encoder.getSizeFromValue(value));\n      if (newSize < 0) {\n        throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n          bytesLength: newSize,\n          codecDescription: \"resizeEncoder\"\n        });\n      }\n      return newSize;\n    }\n  });\n}\nfunction resizeDecoder(decoder, resize) {\n  if (isFixedSize(decoder)) {\n    const fixedSize = resize(decoder.fixedSize);\n    if (fixedSize < 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n        bytesLength: fixedSize,\n        codecDescription: \"resizeDecoder\"\n      });\n    }\n    return createDecoder({ ...decoder, fixedSize });\n  }\n  return decoder;\n}\nfunction resizeCodec(codec, resize) {\n  return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightEncoder(encoder, offset) {\n  return offsetEncoder(\n    resizeEncoder(encoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { preOffset: ({ preOffset }) => preOffset + offset }\n  );\n}\nfunction padRightDecoder(decoder, offset) {\n  return offsetDecoder(\n    resizeDecoder(decoder, (size) => size + offset),\n    { postOffset: ({ postOffset }) => postOffset + offset }\n  );\n}\nfunction padLeftCodec(codec, offset) {\n  return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n  return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n  while (sourceOffset < --sourceLength) {\n    const leftValue = source[sourceOffset];\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n    target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n    sourceOffset++;\n  }\n  if (sourceOffset === sourceLength) {\n    target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n  }\n}\nfunction reverseEncoder(encoder) {\n  assertIsFixedSize(encoder);\n  return createEncoder({\n    ...encoder,\n    write: (value, bytes, offset) => {\n      const newOffset = encoder.write(value, bytes, offset);\n      copySourceToTargetInReverse(\n        bytes,\n        bytes,\n        offset,\n        offset + encoder.fixedSize\n      );\n      return newOffset;\n    }\n  });\n}\nfunction reverseDecoder(decoder) {\n  assertIsFixedSize(decoder);\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const reversedBytes = bytes.slice();\n      copySourceToTargetInReverse(\n        bytes,\n        reversedBytes,\n        offset,\n        offset + decoder.fixedSize\n      );\n      return decoder.read(reversedBytes, offset);\n    }\n  });\n}\nfunction reverseCodec(codec) {\n  return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n  return createEncoder({\n    ...isVariableSize(encoder) ? { ...encoder, getSizeFromValue: (value) => encoder.getSizeFromValue(unmap(value)) } : encoder,\n    write: (value, bytes, offset) => encoder.write(unmap(value), bytes, offset)\n  });\n}\nfunction transformDecoder(decoder, map) {\n  return createDecoder({\n    ...decoder,\n    read: (bytes, offset) => {\n      const [value, newOffset] = decoder.read(bytes, offset);\n      return [map(value, bytes, offset), newOffset];\n    }\n  });\n}\nfunction transformCodec(codec, unmap, map) {\n  return createCodec({\n    ...transformEncoder(codec, unmap),\n    read: map ? transformDecoder(codec, map).read : codec.read\n  });\n}\n\nexport { addCodecSentinel, addCodecSizePrefix, addDecoderSentinel, addDecoderSizePrefix, addEncoderSentinel, addEncoderSizePrefix, assertByteArrayHasEnoughBytesForCodec, assertByteArrayIsNotEmptyForCodec, assertByteArrayOffsetIsNotOutOfRange, assertIsFixedSize, assertIsVariableSize, combineCodec, containsBytes, createCodec, createDecoder, createEncoder, fixBytes, fixCodecSize, fixDecoderSize, fixEncoderSize, getEncodedSize, isFixedSize, isVariableSize, mergeBytes, offsetCodec, offsetDecoder, offsetEncoder, padBytes, padLeftCodec, padLeftDecoder, padLeftEncoder, padRightCodec, padRightDecoder, padRightEncoder, resizeCodec, resizeDecoder, resizeEncoder, reverseCodec, reverseDecoder, reverseEncoder, transformCodec, transformDecoder, transformEncoder };\n\n//# sourceMappingURL=index.browser.mjs.map"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}